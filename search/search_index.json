{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>DesmondTools have a set of command-line scripts and a python library written to make setting up the molecular dynamics simulations easier for Desmond.</p>"},{"location":"index.html#install","title":"Install","text":"<pre><code>$ pip install desmondtools\n</code></pre>"},{"location":"index.html#what-is-multisim-class","title":"What is Multisim Class?","text":"<p>The following code examples from <code>test/test_multisim.py</code> demonstrate the functionality of the Multisim class.</p> <pre><code>from desmondtools import Multisim\n\ndef test_Multisim_variable():\n    # parse_string returns ['barostat.tau']\n    o1 = Multisim.variable.parse_string(\"barostat.tau\")[0]\n    o2 = Multisim.variable.parse_string(\"barostat  .tau\")[0]\n    assert o1 == o2\n\n\ndef test_Multisim_expression_1():\n    i = \"task {} simulate { meta = [{a=1 b=3 c=[7 8 9]}] f = {} } simulate {n=2} simulate {n = 3}\"\n    D = Multisim(string=i).to_dot()\n    assert D.simulate[0].meta[0].b == str(3)\n    assert D.simulate[0].meta[0].c[1] == str(8)\n    assert D.simulate[-1].n == str(3)\n\n\ndef test_Multisim_expression_2():\n    i = \"simulate { effect_if = [[ a ] b ] }\"\n    D = Multisim(string=i).to_dot()\n    assert D.simulate.effect_if[0] == ['a']\n    assert D.simulate.effect_if[1] == 'b'\n\n\ndef test_Multisim_expression_3():\n    i = \"\"\"ensemble = {\n        brownie = {\n            delta_max = 0.1\n        }\n        class = NVT\n        method = Brownie\n        thermostat = {\n            tau = 1.0\n        }\n    }\"\"\"\n    D = Multisim(string=i)\n    assert D.dot.ensemble.brownie.delta_max == str(0.1)\n\n    # assert D.dot.ensemble.class == 'NVT'\n    #                       ^^^^^\n    # SyntaxError: invalid syntax\n    # 'class' is reserved word in python and raises SyntaxError\n    # use instead .['class']\n    assert D.dot.ensemble['class'] == 'NVT' # &lt;--- it does not raise SyntaxError\n\n    assert D.dot.ensemble.method == 'Brownie'\n    assert D.dot.ensemble.thermostat.tau == str(1.0)\n    D.write()\n\n\ndef test_Multisim_expression_4():\n    i = \"\"\"task {\n        task = \"desmond:auto\"\n    }\n    simulate {\n        title = \"NPT and no restraints, 24ps\"\n        effect_if = [[ \"@*.*.annealing\" ] 'annealing = off temperature = \"@*.*.temperature[0][0]\"' ]\n        time = 24\n        ensemble = {\n            class = NPT\n            method = Langevin\n            thermostat.tau = 0.1\n            barostat.tau = 2.0\n        }\n        eneseq.interval = 0.3\n        trajectory.center = solute\n    }\n    simulate {\n        meta = {\n            cv = [\n                { \n                    atom = [0 0 0 0] \n                    type = dihedral \n                    wall = 0  \n                    width = 5.0 \n                }\n            ]\n            cv_name = \"$JOBNAME$[_replica$REPLICA$].cvseq\"\n            first = 0.0\n            height = 0.03\n            interval = 0.09\n            name = \"$JOBNAME$[_replica$REPLICA$].kerseq\"\n        }\n    }\n    \"\"\"\n\n    D = Multisim(string=i)\n\n    assert len(D.dot.simulate[0].effect_if) == 2\n    assert len(D.dot.simulate[0].effect_if[0]) == 1\n    assert D.dot.simulate[0].ensemble.method == 'Langevin'\n    assert D.dot.simulate[0].ensemble.barostat.tau == str(2.0)\n    assert D.dot.simulate[0].eneseq.interval == str(0.3)\n    assert D.dot.simulate[0].trajectory.center == 'solute' # &lt;---\n\n    assert len(D.dot.simulate[1].meta.cv) == 1\n    assert len(D.dot.simulate[1].meta.cv[0].atom) == 4\n    assert D.dot.simulate[1].meta.height == str(0.03)\n    assert D.dot.simulate[-1].meta.cv[0].wall == str(0)\n\n    D.dot.simulate[0].ensemble.barostat.tau = 2.1\n    assert D.dot.simulate[0].ensemble.barostat.tau == 2.1\n\n    D.dot.simulate[1].meta.height = 0.06\n    assert D.dot.simulate[1].meta.height == 0.06\n\n    D.dot.simulate[-1].meta.cv[0].wall = 50.0\n    assert D.dot.simulate[-1].meta.cv[0].wall == 50.0\n\n\ndef test_Multisim_expression_5():\n    D= Multisim(template=\"desmond-md.msj\")\n    D.write()\n</code></pre>"},{"location":"index.html#caution","title":"Caution","text":"<p>Some keywords in the <code>.msj</code> or <code>.cfg</code> files may conflict with the reserved python syntax. In the below example, accessing the <code>class</code> variable by directly using the <code>.dot</code> expression such as <code>D.dot.ensemble.class = 'NVT'</code> would raise a <code>SyntaxError</code> because <code>class</code> is a reserved word in Python. However, you can avoid the error by using a dictionary type access such as <code>D.dot.ensemble['class'] = 'NVT'</code>.</p> <pre><code>    ensemble = {\n        brownie = {\n            delta_max = 0.1\n        }\n        class = NVT\n        method = Brownie\n        thermostat = {\n            tau = 1.0\n        }\n    }\n</code></pre>"},{"location":"index.html#use-of-multisim-class","title":"Use of Multisim Class","text":"<p>The <code>desmondtools.Multisim</code> class facilitates reading and modifying Schrodinger Desmond <code>.msj</code> and <code>.cfg</code> files, which are typically generated by Schrodinger Maestro GUI task panels. By using a simple Python script with <code>desmondtools</code>, you can efficiently prepare and set up multiple MD simulations without repeatedly launching Maestro or manually editing files. The example below demonstrates how to modify or create the contents of <code>.msj</code> and <code>.cfg</code> files using the <code>.dot</code> attribute of a <code>Multisim</code> instance.</p> <pre><code>from desmondtools import Multisim\n\n# read template .msj and .cfg\nmd_msj = Multisim(template=\"desmond-md.msj\")\nmd_cfg = Multisim(template=\"desmond-md.cfg\")\n\nwith open(msj_file,\"w\") as msj:\n    # modify desmond msj template\n    md_msj.dot.simulate[-1].cfg_file = cfg_file_basename\n\n    # Setting up restraints using the restraints keyword:\n    # https://www.schrodinger.com/kb/332119\n    if args.posres_force &gt; 0.0:\n        # print the restraints in the multisim log file\n        md_msj.dot.simulate[-1].print_restraint = 'true'\n\n        # add the new terms defined in \"restraints.new\" to existing restraints.\n        # The default is restraints.existing = ignore which will \n        # delete existing terms before adding any new ones.\n        # md_msj.dot.simulate[-1].restraints.existing = 'retain'\n\n        md_msj.dot.simulate[-1].restraints.new = [\n            {\n                'name'              : 'posre_harm',\n                'atoms'             : [ f'\"{args.posres}\"' ],\n                'force_constants'   : [ args.posres_force, ] * 3,\n            }\n            ]\n        # force constants in the x, y, and z direction\n\n    # writing modified msj\n    md_msj.write(msj)\n\nwith open(cfg_file,\"w\") as cfg:\n    # read and modify desmond cfg template\n    md_cfg.dot.randomize_velocity.seed = random.randint(1000, 9999)\n    md_cfg.dot.time = total_simulation_time\n    md_cfg.dot.temperature = t_schedule\n    md_cfg.dot.trajectory.interval = args.interval\n    # wring modified cfg\n    md_cfg.write(cfg)\n</code></pre> <p>Below are examples of <code>.msj</code> and <code>.cfg</code> files:</p> <pre><code># .msj file example (part)\n\ntask {\n   task = \"desmond:auto\"\n   set_family = {\n      desmond = {\n         checkpt.write_last_step = no\n      }\n   }\n}\n\nsimulate {\n   title       = \"Brownian Dynamics NVT, T = 10 K, small timesteps, ...\"\n   annealing   = off\n   time        = 100\n   timestep    = [0.001 0.001 0.003 ]\n   temperature = 10.0\n   ensemble = {\n      class = \"NVT\"\n      method = \"Brownie\"\n      brownie = {\n         delta_max = 0.1\n      }\n   }\n   restrain = {\n      atom = \"solute_heavy_atom\"\n      force_constant = 50.0\n   }\n}\n\nsimulate {\n   effect_if   = [[\"==\" \"-gpu\" \"@*.*.jlaunch_opt[-1]\"] 'ensemble.method = Langevin']\n   title       = \"NVT, T = 10 K, small timesteps, ...\"\n   annealing   = off\n   time        = 12\n   timestep    = [0.001 0.001 0.003]\n   temperature = 10.0\n   restrain    = { atom = solute_heavy_atom force_constant = 50.0 }\n   ensemble    = {\n      class  = NVT\n      method = Berendsen\n      thermostat.tau = 0.1\n   }\n\n   randomize_velocity.interval = 1.0\n   eneseq.interval             = 0.3\n   trajectory.center           = []\n}\n</code></pre> <pre><code># .cfg file example (part)\n\nrandomize_velocity = {\n   first = 0.0\n   interval = inf\n   seed = 2967\n   temperature = \"@*.temperature\"\n}\nrestrain = none\nsimbox = {\n   first = 0.0\n   interval = 1.2\n   name = \"$JOBNAME$[_replica$REPLICA$]_simbox.dat\"\n}\nsurface_tension = 0.0\ntaper = false\ntemperature = [\n   [300.0 0 ]\n]\ntime = 100000.0\ntimestep = [0.002 0.002 0.006 ]\n</code></pre>"},{"location":"index.html#event-and-interaction-classes","title":"Event and Interaction Classes","text":"<p>Schrodinger event analysis format or <code>.eaf</code> files use the same syntax as the <code>.cfg</code> or <code>.msj</code> files. So, the <code>desmondtools.Multisim</code> class is reused in the <code>desmondtools.Event</code> and <code>desmondtools.Interaction</code> classes to process Schrodinger provided trajectory analysis output <code>...-out.eaf</code> files. For example, below codes from <code>desmondtools.Interaction</code> class shows how the class uses the <code>.dot</code> attributes to process <code>.eaf</code> output files.</p> <pre><code>for section in self.dot.Keywords:\n    try:\n        assert section.ProtLigInter.HBondResult\n        self.num_frames = len(section.ProtLigInter.HBondResult)\n        for frame in section.ProtLigInter.HBondResult:\n            # [[3 \"_:ARG_143:HH22\" d-s \"L-FRAG_0:N6\" ]]\n            for (frameno, prot, hbond_type, lig) in frame:\n                prot = prot.strip('\\\"')\n                (_, resid, atom) = prot.split(\":\")\n                (resName, resSeq) = resid.split(\"_\")\n                resSeq = int(resSeq)\n                if resSeq in self.HBond:\n                    self.HBond[resSeq]['count'] += 1\n                else:\n                    self.HBond[resSeq] = {'resName': resName, 'count':1 }\n        for resSeq in sorted(self.HBond):\n            fraction = float(self.HBond[resSeq]['count'])/self.num_frames\n            if verbose:\n                print(f\"HBond {self.HBond[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n    except:\n        pass\n</code></pre>"},{"location":"index.html#command-line-interface","title":"Command-Line Interface","text":"<p>Command-Line Interfaces (CLI) are built on the <code>Multisim</code> class. Some CLIs require Schrodinger Python API.</p> Command-line interface Description batch-desmond-cif Convert .mae/.maegz to .cif batch-desmond-mdinfo Check running MD simulations batch-desmond-maeinfo Show info of .mae/.maegz file(s) batch-desmond-cmsinfo Show info of .cms file(s) batch-desmond-setup Batch Prepare MD systems batch-desmond-min Batch Setup energy minimizations batch-desmond-md Batch Setup MD simulations batch-desmond-metad Batch Setup metadynamics batch-desmond-report Batch Generate reports batch-desmond-pli Batch Analyze protein-ligand interactions batch-desmond-distance Batch Analyze distance batch-desmond-dihedral Batch Analyze dihedral angles batch-desmond-ligrmsd Batch Analyze ligand rmsd batch-desmond-rg Batch Analyze radius of gyration batch-desmond-rmsx Batch Analyze RMSD and ligand RMSF batch-desmond-mmgbsa Batch Analyze trajectory MMGBSA <p>For more helps, <code>$ command --help</code>.</p>"},{"location":"index.html#metadynamics","title":"Metadynamics","text":""},{"location":"index.html#types-of-collective-variables","title":"Types of Collective Variables","text":"type Description Default Width Wall Floor Atom sites dist Distance 0.05 \u00c5 yes yes 2 angle Angle 2.5\u00b0 yes yes 3 dihedral Dihedral 5.0\u00b0 no no 4 rgyr Radius of gyration 0.1 \u00c5 no no 1 rgyr_mass Mass-weighted radius of gyration 0.1 \u00c5 no no 1 rmsd RMSD from aligned starting structure 0.1 \u00c5 no no 1 rmsd_symm Symmetry aware RMSD 0.1 \u00c5 no no 1 zdist Distance along the z axis 0.05 \u00c5 yes yes 1 zdist0 Absolute distance along the z axis 0.1 \u00c5 yes yes 1 whim1 WHIM1 - first principal moment [35] 0.5 \u00c52 no no 1 whim2 WHIM2 - second principal moment [35] 0.25 \u00c52 no no 1"},{"location":"index.html#examples-of-collective-variables","title":"Examples of Collective Variables","text":"<pre><code>distance:\n    cv = [\n        {atom = [\"res. UNK\" \"res. 849\" ]\n        type = dist\n        wall = 40\n        floor = 10\n        width = 0.05\n        }\n    ]\n\ndihedral:\n    cv = [\n        {atom = [404 406 407 415 ]\n        type = dihedral\n        width = 5.0\n        }\n        {atom = [406 407 415 417 ]\n        type = dihedral\n        width = 5.0\n        }\n    ]\n\nzdist(membrane):\n    cv = [\n        {atom = [\"res. UNK\"]\n        type = zdist\n        width = 0.05\n        wall = 20\n        floor = 5\n        }\n        ]\n\nrmsd:\n    cv = [\n        {atom = [\"res. UNK\" \"res. 849\" ]\n        type = rmsd\n        width = 0.1\n        }\n    ]\n</code></pre>"},{"location":"index.html#well-tempered-metadynamics","title":"Well-Tempered Metadynamics","text":"<p>In well-tempered metadynamics, the height of the deployed Gaussians are rescaled (decreased) during simulation time by: omega_0 * exp(-V/(kB * \u0394T)) Where omega_0 is the initial hill height, V is the bias potential and the denominator in the exponential, kB * \u0394T, is the bias factor (kTemp). During well-tempered metadynamics, the dynamics of the system are effectively accelerated  (without heating up the system) up to T + \u0394T, where T is the chosen MD simulation temperature.  The choice of the bias factor value is guided by the highest barrier in the simulation system  which the well-tempered metadynamics run should overcome. Here are some suggestions,  assuming that the initial hill height \u03c90 (height parameter in the Metadynamics panel) has been set to 0.3 kcal/mol:</p> Max. barrier height (kcal/mol) kTemp (kcal/mol) 3 1.7 6 3.4 10 5.6 15 8.4 20 11.2"},{"location":"index.html#extending-simulations","title":"Extending Simulations","text":"<p>See https://www.schrodinger.com/kb/788642 for extending metadynamics simulation.</p>"},{"location":"index.html#python-classes","title":"Python Classes","text":""},{"location":"index.html#desmondtools.Multisim","title":"<code>desmondtools.Multisim</code>","text":"<p>Parsing Desmond multisim .cfg and .msj expressions</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>class Multisim:\n    \"\"\"Parsing Desmond multisim .cfg and .msj expressions\"\"\"\n    # variable, value, array, expr\n    # pyparsing module\u2019s default behavior is to ignore whitespace.\n    # +: AND, |: MatchFirst, left-to-right, ^: Or(longest match)\n    # Group: --&gt; list\n    # Dict: --&gt; dict\n    # Forward: --&gt; recursive\n\n    EQ = pp.Suppress('=')\n    LBRACKET, RBRACKET, LBRACE, RBRACE = map(pp.Literal, \"[]{}\")\n    variable = (pp.Word(pp.alphanums + \"._/?-@\") + \n                pp.Opt(\".\" + pp.Word(pp.alphanums))).set_parse_action(''.join)\n    _string1 = pp.Word(pp.alphanums + \"._/?-@*\")\n    _string2 = pp.quoted_string()\n    _number  = ppc.number()\n    value   = (_string1 | _string2 | _number)\n    array   = pp.Forward()\n    array   &lt;&lt;= pp.Group(LBRACKET + (pp.ZeroOrMore(value | array)) + RBRACKET)\n    expr    = pp.Forward()\n    _expr_0  = (variable + EQ + value)\n    _expr_1  = (variable + EQ + array)\n    _expr_2  = (variable + EQ + pp.Group(\n        LBRACE + pp.ZeroOrMore(expr) + RBRACE ))\n    _expr_3  = (variable + EQ + pp.Group(\n        LBRACKET + pp.ZeroOrMore(pp.Group(LBRACE + expr + RBRACE)) + RBRACKET))\n    _expr_4  = pp.Group(variable + pp.Group(\n        LBRACE + pp.ZeroOrMore( expr ) + RBRACE))\n    expr    &lt;&lt;= pp.OneOrMore(pp.Dict(pp.Group(\n        _expr_0 | _expr_1 | _expr_2 | _expr_3 | _expr_4)))\n    expr.ignore(\"#\" + pp.restOfLine)\n\n\n    def __init__(self, **kwargs):\n        self.template_path = None\n        self.ParseResults = None\n        self.dict = {}\n        self.dot = DotMap()\n        self.output = sys.stdout # do not attempt to close\n        self.indent = 4\n\n        if 'template' in kwargs:\n            template = kwargs['template']\n            template_path = pathlib.Path(template)\n            if template_path.is_file():\n                self.template_path = template_path\n            else:\n                template_path = importlib.resources.files('desmondtools')\n                self.template_path = template_path / template\n            if self.template_path is None:\n                raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), template)\n\n            self.ParseResults = Multisim.expr.parse_file(self.template_path)\n            self.decode()\n\n        elif 'string' in kwargs:\n            string = kwargs['string']\n            try:\n                self.ParseResults = Multisim.expr.parse_string(string)\n                self.decode()\n            except:\n                raise RuntimeError(\"Multisim: cannot parse the input string.\")\n        else:\n            raise RuntimeError(\"Multisim: template filename or string is required.\")\n\n\n\n    @staticmethod\n    def unfold_dict_key(d) -&gt; None:\n        \"\"\"Unfold '.' in the keys of a dictionary\n\n        Args:\n            d (dict): dictionary (to be modified)\n        \"\"\"\n        ks = [ k for k in d ]\n        for k in ks:\n            v = d[k]\n            if '.' in k:\n                # d[k] = v --&gt; d[kk[0]] = { kk[1] : v }\n                _u = None\n                _k = k.split('.')[0]\n                for kk in k.split('.')[-1:0:-1]:\n                    if _u is None:\n                        _u = {kk : v }\n                    else:\n                        _u = {kk : _u}\n                d[_k] = _u\n                del d[k]\n            else:\n                pass\n            if isinstance(v, dict):\n                Multisim.unfold_dict_key(v)\n\n\n    @staticmethod\n    def traverse_dict(d) -&gt; None:\n        \"\"\"Recursively traverse a nested dictionary/list\n\n        Args:\n            d (dict): dictionary (to be modified)\n        \"\"\"\n        if isinstance(d, dict):\n            for k,v in d.items():\n                if isinstance(v, dict):\n                    Multisim.traverse_dict(v)            \n                elif isinstance(v, list):\n                    if v == ['{','}']:\n                        d[k] = {}\n                    elif v == ['[',']']:\n                        d[k] = []\n                    elif v[0] == '[' and v[-1] == ']':\n                        d[k] = v[1:-1]\n                        Multisim.traverse_dict(d[k])\n                    elif v[0] == '{' and v[-1] == '}':\n                        d[k] = dict(v[1:-1])\n                        Multisim.traverse_dict(d[k])\n        elif isinstance(d, list):\n            for k,v in enumerate(d):\n                if isinstance(v, dict):\n                    Multisim.traverse_dict(v)\n                elif isinstance(v, list):\n                    if v == ['{','}']:\n                        d[k] = {}\n                    elif v == ['[',']']:\n                        d[k] = []\n                    elif v[0] == '[' and v[-1] == ']':\n                        d[k] = v[1:-1]\n                        Multisim.traverse_dict(d[k])\n                    elif v[0] == '{' and v[-1] == '}':\n                        d[k] = dict(v[1:-1])\n                        Multisim.traverse_dict(d[k])\n\n\n    def decode(self) -&gt; None:\n        \"\"\"decode the parsed results into a dictionary and its dotmap\"\"\"\n        # create .dict\n        if isinstance(self.ParseResults.as_list()[0][0], str): # key\n            self.dict = self.ParseResults.as_dict()\n            Multisim.traverse_dict(self.dict)\n            # handle the case where key has '.'\n            Multisim.unfold_dict_key(self.dict)\n\n        elif isinstance(self.ParseResults.as_list()[0][0], list):\n            self.dict = [] # now self.dict is a list of dictionary\n            for section in self.ParseResults:\n                dict_ = dict(section.as_list())\n                Multisim.traverse_dict(dict_)\n                # handle the case where key has '.'\n                Multisim.unfold_dict_key(dict_)\n                self.dict.append(dict_)\n\n        # create .dot\n        if isinstance(self.dict, list):\n            self.dot = {}\n            for d in self.dict:\n                for k,v in d.items():\n                    if k in self.dot:\n                        if isinstance(self.dot[k], list):\n                            self.dot[k].append(v)\n                        else:\n                            self.dot[k] = [self.dot[k], v]\n                    else:\n                        self.dot[k] = v\n            self.dot = DotMap(self.dot)\n        else:\n            self.dot = DotMap(self.dict)\n\n\n\n    def write(self, output=None):\n        \"\"\"Writes DOT object\"\"\"\n        if isinstance(output, io.IOBase):\n            self.output = output\n        elif isinstance(output, str):\n            self.output = open(output, \"w\")\n\n        if isinstance(self.dict, list):\n            blocks = []\n            for k, v in self.dot.items():\n                if isinstance(v, list):\n                    for vv in v:\n                        blocks.append({k:vv})\n                else:\n                    blocks.append({k:v})\n            for block in blocks:\n                self._write_dict(block, block=True)\n                self.output.write(\"\\n\")\n        else:\n            self._write_dict(self.dot)\n\n\n    def _write_dict(self, d, block=False, depth=0):\n        \"\"\"subroutine of .write() method\"\"\"\n        spc = ' ' * self.indent * depth\n        if isinstance(d, dict) or isinstance(d, DotMap):\n            for k, v in d.items():\n                k = str(k)\n                if v:\n                    if isinstance(v, dict) or isinstance(v, DotMap):\n                        if depth == 0 and block:\n                            self.output.write(spc + k + \" {\\n\")\n                        else:\n                            self.output.write(spc + k + \" = {\\n\")\n                        self._write_dict(v, depth=depth+1)\n                        self.output.write(spc + \"}\\n\")\n                    elif isinstance(v, list):\n                        self.output.write(spc + k + \" = [\")\n                        for vv in v:\n                            if isinstance(vv, dict) or isinstance(vv, DotMap): \n                                self.output.write(\"{\\n\")\n                            elif isinstance(vv, list):\n                                self.output.write(\"[\")\n                            self._write_dict(vv, depth=depth+1)\n                            if isinstance(vv, dict) or isinstance(vv, DotMap):\n                                self.output.write(spc + \"}\")\n                            elif isinstance(vv, list):\n                                self.output.write(\"]\")                \n                        self.output.write(\"]\\n\")\n                    else:\n                        self.output.write(spc + k + \" = \" + str(v) +\"\\n\")\n                else:\n                    if isinstance(v, list) and (not bool(v)):\n                        self.output.write(spc + k + \" = []\\n\")\n                    elif (isinstance(v, dict) or isinstance(v, DotMap))and (not bool(v)):\n                        self.output.write(spc + k + \" = {\\n}\\n\")\n                    else:\n                        self.output.write(spc + k + \" =   \\n\")\n        elif isinstance(d, list):\n            for v in d:\n                self._write_dict(v, depth=depth+1)\n        else:\n            self.output.write(\" \" + str(d) + \" \")\n\n\n    def to_dot(self) -&gt; DotMap:\n        \"\"\"Returns parsed results as a DotMap object\n\n        Returns:\n            DotMap : DotMap object\n        \"\"\"\n        return self.dot\n\n\n    def to_list(self) -&gt; list:\n        \"\"\"Returns parsed results as a list\n\n        Returns:\n            list : list\n        \"\"\"\n        return self.ParseResults.as_list()\n\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Returns parsed results as a dictionary\n\n        Returns:\n            dict : dictionary\n        \"\"\"\n        return self.dict\n</code></pre>"},{"location":"index.html#desmondtools.Multisim-attributes","title":"Attributes","text":""},{"location":"index.html#desmondtools.Multisim.EQ","title":"<code>EQ = pp.Suppress('=')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.ParseResults","title":"<code>ParseResults = Multisim.expr.parse_string(string)</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_0","title":"<code>_expr_0 = variable + EQ + value</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_1","title":"<code>_expr_1 = variable + EQ + array</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_2","title":"<code>_expr_2 = variable + EQ + pp.Group(LBRACE + pp.ZeroOrMore(expr) + RBRACE)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_3","title":"<code>_expr_3 = variable + EQ + pp.Group(LBRACKET + pp.ZeroOrMore(pp.Group(LBRACE + expr + RBRACE)) + RBRACKET)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_4","title":"<code>_expr_4 = pp.Group(variable + pp.Group(LBRACE + pp.ZeroOrMore(expr) + RBRACE))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._number","title":"<code>_number = ppc.number()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._string1","title":"<code>_string1 = pp.Word(pp.alphanums + '._/?-@*')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._string2","title":"<code>_string2 = pp.quoted_string()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.array","title":"<code>array = pp.Forward()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.dict","title":"<code>dict = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.dot","title":"<code>dot = DotMap()</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.expr","title":"<code>expr = pp.Forward()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.indent","title":"<code>indent = 4</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.output","title":"<code>output = sys.stdout</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.template_path","title":"<code>template_path = None</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.value","title":"<code>value = _string1 | _string2 | _number</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.variable","title":"<code>variable = pp.Word(pp.alphanums + '._/?-@') + pp.Opt('.' + pp.Word(pp.alphanums)).set_parse_action(''.join)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim-functions","title":"Functions","text":""},{"location":"index.html#desmondtools.Multisim.__init__","title":"<code>__init__(**kwargs)</code>","text":"Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def __init__(self, **kwargs):\n    self.template_path = None\n    self.ParseResults = None\n    self.dict = {}\n    self.dot = DotMap()\n    self.output = sys.stdout # do not attempt to close\n    self.indent = 4\n\n    if 'template' in kwargs:\n        template = kwargs['template']\n        template_path = pathlib.Path(template)\n        if template_path.is_file():\n            self.template_path = template_path\n        else:\n            template_path = importlib.resources.files('desmondtools')\n            self.template_path = template_path / template\n        if self.template_path is None:\n            raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), template)\n\n        self.ParseResults = Multisim.expr.parse_file(self.template_path)\n        self.decode()\n\n    elif 'string' in kwargs:\n        string = kwargs['string']\n        try:\n            self.ParseResults = Multisim.expr.parse_string(string)\n            self.decode()\n        except:\n            raise RuntimeError(\"Multisim: cannot parse the input string.\")\n    else:\n        raise RuntimeError(\"Multisim: template filename or string is required.\")\n</code></pre>"},{"location":"index.html#desmondtools.Multisim._write_dict","title":"<code>_write_dict(d, block=False, depth=0)</code>","text":"<p>subroutine of .write() method</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def _write_dict(self, d, block=False, depth=0):\n    \"\"\"subroutine of .write() method\"\"\"\n    spc = ' ' * self.indent * depth\n    if isinstance(d, dict) or isinstance(d, DotMap):\n        for k, v in d.items():\n            k = str(k)\n            if v:\n                if isinstance(v, dict) or isinstance(v, DotMap):\n                    if depth == 0 and block:\n                        self.output.write(spc + k + \" {\\n\")\n                    else:\n                        self.output.write(spc + k + \" = {\\n\")\n                    self._write_dict(v, depth=depth+1)\n                    self.output.write(spc + \"}\\n\")\n                elif isinstance(v, list):\n                    self.output.write(spc + k + \" = [\")\n                    for vv in v:\n                        if isinstance(vv, dict) or isinstance(vv, DotMap): \n                            self.output.write(\"{\\n\")\n                        elif isinstance(vv, list):\n                            self.output.write(\"[\")\n                        self._write_dict(vv, depth=depth+1)\n                        if isinstance(vv, dict) or isinstance(vv, DotMap):\n                            self.output.write(spc + \"}\")\n                        elif isinstance(vv, list):\n                            self.output.write(\"]\")                \n                    self.output.write(\"]\\n\")\n                else:\n                    self.output.write(spc + k + \" = \" + str(v) +\"\\n\")\n            else:\n                if isinstance(v, list) and (not bool(v)):\n                    self.output.write(spc + k + \" = []\\n\")\n                elif (isinstance(v, dict) or isinstance(v, DotMap))and (not bool(v)):\n                    self.output.write(spc + k + \" = {\\n}\\n\")\n                else:\n                    self.output.write(spc + k + \" =   \\n\")\n    elif isinstance(d, list):\n        for v in d:\n            self._write_dict(v, depth=depth+1)\n    else:\n        self.output.write(\" \" + str(d) + \" \")\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.decode","title":"<code>decode()</code>","text":"<p>decode the parsed results into a dictionary and its dotmap</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def decode(self) -&gt; None:\n    \"\"\"decode the parsed results into a dictionary and its dotmap\"\"\"\n    # create .dict\n    if isinstance(self.ParseResults.as_list()[0][0], str): # key\n        self.dict = self.ParseResults.as_dict()\n        Multisim.traverse_dict(self.dict)\n        # handle the case where key has '.'\n        Multisim.unfold_dict_key(self.dict)\n\n    elif isinstance(self.ParseResults.as_list()[0][0], list):\n        self.dict = [] # now self.dict is a list of dictionary\n        for section in self.ParseResults:\n            dict_ = dict(section.as_list())\n            Multisim.traverse_dict(dict_)\n            # handle the case where key has '.'\n            Multisim.unfold_dict_key(dict_)\n            self.dict.append(dict_)\n\n    # create .dot\n    if isinstance(self.dict, list):\n        self.dot = {}\n        for d in self.dict:\n            for k,v in d.items():\n                if k in self.dot:\n                    if isinstance(self.dot[k], list):\n                        self.dot[k].append(v)\n                    else:\n                        self.dot[k] = [self.dot[k], v]\n                else:\n                    self.dot[k] = v\n        self.dot = DotMap(self.dot)\n    else:\n        self.dot = DotMap(self.dict)\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns parsed results as a dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Returns parsed results as a dictionary\n\n    Returns:\n        dict : dictionary\n    \"\"\"\n    return self.dict\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_dot","title":"<code>to_dot()</code>","text":"<p>Returns parsed results as a DotMap object</p> <p>Returns:</p> Name Type Description <code>DotMap</code> <code>DotMap</code> <p>DotMap object</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def to_dot(self) -&gt; DotMap:\n    \"\"\"Returns parsed results as a DotMap object\n\n    Returns:\n        DotMap : DotMap object\n    \"\"\"\n    return self.dot\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_list","title":"<code>to_list()</code>","text":"<p>Returns parsed results as a list</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def to_list(self) -&gt; list:\n    \"\"\"Returns parsed results as a list\n\n    Returns:\n        list : list\n    \"\"\"\n    return self.ParseResults.as_list()\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.traverse_dict","title":"<code>traverse_dict(d)</code>  <code>staticmethod</code>","text":"<p>Recursively traverse a nested dictionary/list</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>dictionary (to be modified)</p> required Source code in <code>src/desmondtools/multisim.py</code> <pre><code>@staticmethod\ndef traverse_dict(d) -&gt; None:\n    \"\"\"Recursively traverse a nested dictionary/list\n\n    Args:\n        d (dict): dictionary (to be modified)\n    \"\"\"\n    if isinstance(d, dict):\n        for k,v in d.items():\n            if isinstance(v, dict):\n                Multisim.traverse_dict(v)            \n            elif isinstance(v, list):\n                if v == ['{','}']:\n                    d[k] = {}\n                elif v == ['[',']']:\n                    d[k] = []\n                elif v[0] == '[' and v[-1] == ']':\n                    d[k] = v[1:-1]\n                    Multisim.traverse_dict(d[k])\n                elif v[0] == '{' and v[-1] == '}':\n                    d[k] = dict(v[1:-1])\n                    Multisim.traverse_dict(d[k])\n    elif isinstance(d, list):\n        for k,v in enumerate(d):\n            if isinstance(v, dict):\n                Multisim.traverse_dict(v)\n            elif isinstance(v, list):\n                if v == ['{','}']:\n                    d[k] = {}\n                elif v == ['[',']']:\n                    d[k] = []\n                elif v[0] == '[' and v[-1] == ']':\n                    d[k] = v[1:-1]\n                    Multisim.traverse_dict(d[k])\n                elif v[0] == '{' and v[-1] == '}':\n                    d[k] = dict(v[1:-1])\n                    Multisim.traverse_dict(d[k])\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.traverse_dict(d)","title":"<code>d</code>","text":""},{"location":"index.html#desmondtools.Multisim.unfold_dict_key","title":"<code>unfold_dict_key(d)</code>  <code>staticmethod</code>","text":"<p>Unfold '.' in the keys of a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>dictionary (to be modified)</p> required Source code in <code>src/desmondtools/multisim.py</code> <pre><code>@staticmethod\ndef unfold_dict_key(d) -&gt; None:\n    \"\"\"Unfold '.' in the keys of a dictionary\n\n    Args:\n        d (dict): dictionary (to be modified)\n    \"\"\"\n    ks = [ k for k in d ]\n    for k in ks:\n        v = d[k]\n        if '.' in k:\n            # d[k] = v --&gt; d[kk[0]] = { kk[1] : v }\n            _u = None\n            _k = k.split('.')[0]\n            for kk in k.split('.')[-1:0:-1]:\n                if _u is None:\n                    _u = {kk : v }\n                else:\n                    _u = {kk : _u}\n            d[_k] = _u\n            del d[k]\n        else:\n            pass\n        if isinstance(v, dict):\n            Multisim.unfold_dict_key(v)\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.unfold_dict_key(d)","title":"<code>d</code>","text":""},{"location":"index.html#desmondtools.Multisim.write","title":"<code>write(output=None)</code>","text":"<p>Writes DOT object</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def write(self, output=None):\n    \"\"\"Writes DOT object\"\"\"\n    if isinstance(output, io.IOBase):\n        self.output = output\n    elif isinstance(output, str):\n        self.output = open(output, \"w\")\n\n    if isinstance(self.dict, list):\n        blocks = []\n        for k, v in self.dot.items():\n            if isinstance(v, list):\n                for vv in v:\n                    blocks.append({k:vv})\n            else:\n                blocks.append({k:v})\n        for block in blocks:\n            self._write_dict(block, block=True)\n            self.output.write(\"\\n\")\n    else:\n        self._write_dict(self.dot)\n</code></pre>"},{"location":"index.html#desmondtools.Event","title":"<code>desmondtools.Event</code>","text":"Source code in <code>src/desmondtools/event.py</code> <pre><code>class Event:\n    def __init__(self, filename:Path | str):\n        if isinstance(filename, Path):\n            result = Multisim.expr.parse_file(filename.as_posix())\n        else:\n            result = Multisim.expr.parse_file(filename)\n        d = result.as_dict()\n        Multisim.traverse_dict(d)\n        self.dot = DotMap(d)\n</code></pre>"},{"location":"index.html#desmondtools.Event-attributes","title":"Attributes","text":""},{"location":"index.html#desmondtools.Event.dot","title":"<code>dot = DotMap(d)</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Event-functions","title":"Functions","text":""},{"location":"index.html#desmondtools.Event.__init__","title":"<code>__init__(filename)</code>","text":"Source code in <code>src/desmondtools/event.py</code> <pre><code>def __init__(self, filename:Path | str):\n    if isinstance(filename, Path):\n        result = Multisim.expr.parse_file(filename.as_posix())\n    else:\n        result = Multisim.expr.parse_file(filename)\n    d = result.as_dict()\n    Multisim.traverse_dict(d)\n    self.dot = DotMap(d)\n</code></pre>"},{"location":"index.html#desmondtools.Interaction","title":"<code>desmondtools.Interaction</code>","text":"<p>               Bases: <code>Event</code></p> Source code in <code>src/desmondtools/event.py</code> <pre><code>class Interaction(Event):\n    def __init__(self, filename:Path | str, verbose:bool=False):\n        super().__init__(filename)\n\n        self.num_frames = 0\n        self.HBond = {}\n        self.Hydrophobic = {}\n        self.WaterBridge = {}\n        self.Polar = {}\n        self.HalogenBond = {}\n        self.LigWat = {}\n        self.Metal = {}\n        self.PiCat = {}\n        self.PiPi = {}\n\n        for section in self.dot.Keywords:\n            try:\n                assert section.ProtLigInter.HBondResult\n                self.num_frames = len(section.ProtLigInter.HBondResult)\n                for frame in section.ProtLigInter.HBondResult:\n                    # [[3 \"_:ARG_143:HH22\" d-s \"L-FRAG_0:N6\" ]]\n                    for (frameno, prot, hbond_type, lig) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid, atom) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.HBond:\n                            self.HBond[resSeq]['count'] += 1\n                        else:\n                            self.HBond[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.HBond):\n                    fraction = float(self.HBond[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"HBond {self.HBond[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n\n            try:\n                assert section.ProtLigInter.HydrophobicResult\n                self.num_frames = len(section.ProtLigInter.HydrophobicResult)\n                for frame in section.ProtLigInter.HydrophobicResult:\n                    # [[0 \"_:PHE_223\" L-FRAG_0 ] [0 \"_:ALA_241\" L-FRAG_0 ]]\n                    for (frameno, prot, lig) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.Hydrophobic:\n                            self.Hydrophobic[resSeq]['count'] += 1\n                        else:\n                            self.Hydrophobic[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.Hydrophobic):\n                    fraction = float(self.Hydrophobic[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"Hydrophobic {self.Hydrophobic[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n\n            try:\n                assert section.ProtLigInter.PolarResult\n                self.num_frames = len(section.ProtLigInter.PolarResult)\n                for frame in section.ProtLigInter.PolarResult:\n                    # [[1 \"_:GLU_216:OE2\" b \"L-FRAG_1:N3\" 4.45 ]]\n                    for (frameno, prot, _, lig, _) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid, atom) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.Polar:\n                            self.Polar[resSeq]['count'] += 1\n                        else:\n                            self.Polar[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.Polar):\n                    fraction = float(self.Polar[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"Polar {self.Polar[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n\n            try:\n                assert section.ProtLigInter.WaterBridgeResult\n                self.num_frames = len(section.ProtLigInter.WaterBridgeResult)\n                for frame in section.ProtLigInter.WaterBridgeResult:\n                    # [[3 \"_:GLU_216:OE2\" a \"L-FRAG_0:N2\" a 2431 ]]\n                    for (frameno, prot, _, lig, _, _) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid, atom) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.WaterBridge:\n                            self.WaterBridge[resSeq]['count'] += 1\n                        else:\n                            self.WaterBridge[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.WaterBridge):\n                    fraction = float(self.WaterBridge[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"WaterBridge {self.WaterBridge[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n</code></pre>"},{"location":"index.html#desmondtools.Interaction-attributes","title":"Attributes","text":""},{"location":"index.html#desmondtools.Interaction.HBond","title":"<code>HBond = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.HalogenBond","title":"<code>HalogenBond = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.Hydrophobic","title":"<code>Hydrophobic = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.LigWat","title":"<code>LigWat = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.Metal","title":"<code>Metal = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.PiCat","title":"<code>PiCat = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.PiPi","title":"<code>PiPi = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.Polar","title":"<code>Polar = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.WaterBridge","title":"<code>WaterBridge = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.num_frames","title":"<code>num_frames = len(section.ProtLigInter.WaterBridgeResult)</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction-functions","title":"Functions","text":""},{"location":"index.html#desmondtools.Interaction.__init__","title":"<code>__init__(filename, verbose=False)</code>","text":"Source code in <code>src/desmondtools/event.py</code> <pre><code>def __init__(self, filename:Path | str, verbose:bool=False):\n    super().__init__(filename)\n\n    self.num_frames = 0\n    self.HBond = {}\n    self.Hydrophobic = {}\n    self.WaterBridge = {}\n    self.Polar = {}\n    self.HalogenBond = {}\n    self.LigWat = {}\n    self.Metal = {}\n    self.PiCat = {}\n    self.PiPi = {}\n\n    for section in self.dot.Keywords:\n        try:\n            assert section.ProtLigInter.HBondResult\n            self.num_frames = len(section.ProtLigInter.HBondResult)\n            for frame in section.ProtLigInter.HBondResult:\n                # [[3 \"_:ARG_143:HH22\" d-s \"L-FRAG_0:N6\" ]]\n                for (frameno, prot, hbond_type, lig) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.HBond:\n                        self.HBond[resSeq]['count'] += 1\n                    else:\n                        self.HBond[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.HBond):\n                fraction = float(self.HBond[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"HBond {self.HBond[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.HydrophobicResult\n            self.num_frames = len(section.ProtLigInter.HydrophobicResult)\n            for frame in section.ProtLigInter.HydrophobicResult:\n                # [[0 \"_:PHE_223\" L-FRAG_0 ] [0 \"_:ALA_241\" L-FRAG_0 ]]\n                for (frameno, prot, lig) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.Hydrophobic:\n                        self.Hydrophobic[resSeq]['count'] += 1\n                    else:\n                        self.Hydrophobic[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.Hydrophobic):\n                fraction = float(self.Hydrophobic[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"Hydrophobic {self.Hydrophobic[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.PolarResult\n            self.num_frames = len(section.ProtLigInter.PolarResult)\n            for frame in section.ProtLigInter.PolarResult:\n                # [[1 \"_:GLU_216:OE2\" b \"L-FRAG_1:N3\" 4.45 ]]\n                for (frameno, prot, _, lig, _) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.Polar:\n                        self.Polar[resSeq]['count'] += 1\n                    else:\n                        self.Polar[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.Polar):\n                fraction = float(self.Polar[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"Polar {self.Polar[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.WaterBridgeResult\n            self.num_frames = len(section.ProtLigInter.WaterBridgeResult)\n            for frame in section.ProtLigInter.WaterBridgeResult:\n                # [[3 \"_:GLU_216:OE2\" a \"L-FRAG_0:N2\" a 2431 ]]\n                for (frameno, prot, _, lig, _, _) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.WaterBridge:\n                        self.WaterBridge[resSeq]['count'] += 1\n                    else:\n                        self.WaterBridge[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.WaterBridge):\n                fraction = float(self.WaterBridge[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"WaterBridge {self.WaterBridge[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n</code></pre>"},{"location":"index.html#desmondtools.Maestro","title":"<code>desmondtools.Maestro</code>","text":"<p>export maestro file in mmcif format</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>class Maestro:\n    \"\"\" export maestro file in mmcif format \"\"\"\n\n    def __init__(self, filename:str, max_two_entries:bool=True) -&gt; None:\n        \"\"\" initialize \"\"\"\n\n        if filename.endswith('.maegz'):\n            self.prefix = filename.replace(\".maegz\",\"\")\n            self.maesto_file = gzip.open(filename, \"rt\")\n        elif filename.endswith('.mae.gz'):\n            self.prefix = filename.replace(\".mae.gz\",\"\")\n            self.maesto_file = gzip.open(filename, \"rt\")\n        elif filename.endswith('.mae'):\n            self.prefix = filename.replace(\".mae\",\"\")\n            self.maesto_file = open(filename, \"rt\")\n        else:\n            print(\".mae, .mae.gz, or .maegz are expected\")\n            sys.exit(0)\n\n        # standard DNA/RNA/Protein\n        self.std_residues = [\n            \"ADE\", \"GUA\", \"CYT\", \"URA\", \"THY\",\n            \"ALA\", \"ARG\", \"ASN\", \"ASP\", \"CYS\", \"GLN\", \"GLU\", \"GLY\", \"HIS\", \"ILE\",\n            \"LEU\", \"LYS\", \"MET\", \"PHE\", \"PRO\", \"SER\", \"THR\", \"TRP\", \"TYR\", \"VAL\",\n        ]\n\n        # conversion to standard residue name\n        self.std_rename = {\n            \"URI\" : \"URA\",\n            \"CYX\" : \"CYS\", # disulfide-bonded\n            \"CYM\" : \"CYS\", # deprotonated (- charge) and/or bound to metal atoms\n            \"HID\" : \"HIS\", # protonated at delta position\n            \"HIE\" : \"HIS\", # protonated at epsilon\n            \"HIP\" : \"HIS\", # protonated at both delta and epsilon\n        } \n\n        self.atomic_symbol = {\n             1 : \"H\",   2 : \"He\",  3 : \"Li\",  4 : \"Be\",  5 : \"B\",   6 : \"C\",   7 : \"N\",   8 : \"O\",   9 : \"F\",  10 : \"Ne\",\n            11 : \"Na\", 12 : \"Mg\", 13 : \"Al\", 14 : \"Si\", 15 : \"P\",  16 : \"S\",  17 : \"Cl\", 18 : \"Ar\", 19 : \"K\",  20 : \"Ca\",\n            21 : \"Sc\", 22 : \"Ti\", 23 : \"V\",  24 : \"Cr\", 25 : \"Mn\", 26 : \"Fe\", 27 : \"Co\", 28 : \"Ni\", 29 : \"Cu\", 30 : \"Zn\",\n            31 : \"Ga\", 32 : \"Ge\", 33 : \"As\", 34 : \"Se\", 35 : \"Br\", 36 : \"Kr\", 37 : \"Rb\", 38 : \"Sr\", 39 : \"Y\",  40 : \"Zr\",\n            41 : \"Nb\", 42 : \"Mo\", 43 : \"Tc\", 44 : \"Ru\", 45 : \"Rh\", 46 : \"Pd\", 47 : \"Ag\", 48 : \"Cd\", 49 : \"In\", 50 : \"Sn\",\n            51 : \"Sb\", 52 : \"Te\", 53 : \"I\",  54 : \"Xe\", 55 : \"Cs\", 56 : \"Ba\", 57 : \"La\", 58 : \"Ce\", 59 : \"Pr\", 60 : \"Nd\",\n            61 : \"Pm\", 62 : \"Sm\", 63 : \"Eu\", 64 : \"Gd\", 65 : \"Tb\", 66 : \"Dy\", 67 : \"Ho\", 68 : \"Er\", 69 : \"Tm\", 70 : \"Yb\",\n            71 : \"Lu\", 72 : \"Hf\", 73 : \"Ta\", 74 : \"W\",  75 : \"Re\", 76 : \"Os\", 77 : \"Ir\", 78 : \"Pt\", 79 : \"Au\", 80 : \"Hg\",\n            81 : \"Tl\", 82 : \"Pb\", 83 : \"Bi\", 84 : \"Po\", 85 : \"At\", 86 : \"Rn\", 87 : \"Fr\", 88 : \"Ra\", 89 : \"Ac\", 90 : \"Th\",\n            91 : \"Pa\", 92 : \"U\",  93 : \"Np\", 94 : \"Pu\", 95 : \"Am\", 96 : \"Cm\", 97 : \"Bk\", 98 : \"Cf\", 99 : \"Es\", 100: \"Fm\",\n            101: \"Md\", 102: \"No\", 103: \"Lr\", 104: \"Rf\", 105: \"Db\", 106: \"Sg\", 107: \"Bh\", 108: \"Hs\", 109: \"Mt\", 110: \"Ds\",\n            111: \"Rg\", 112: \"Cn\", 113: \"Nh\", 114: \"Fl\", 115: \"Mc\", 116: \"Lv\", 117: \"Ts\", 118: \"Og\",\n        }\n\n        self.max_two_entries = max_two_entries\n        self.count = re.compile(r'\\[(\\d+)\\]')\n        self.title = \"\"\n        self.serial = 0\n        self.usedId = {}\n        self.mmcif = {\n            \"_entry\": None, \n            \"_chem_comp_bond\": None, \n            \"_atom_site\": None,\n            } # mmcif-like object\n        self.iamap = {}\n\n\n    def append_entry(self, title):\n        \"\"\" start a new entry \"\"\"\n\n        if self.mmcif[\"_entry\"]:\n            if type(self.mmcif[\"_entry\"][\"id\"]) == list:\n                # you got here as the third and later entry\n                if self.max_two_entries:\n                    # write out last two entries\n                    self.write_mmcif()\n                    # return to the state in which only the first entry was defined\n                    self.mmcif = copy.deepcopy(self.mmcif_first)\n                    self.usedId = copy.deepcopy(self.mmcif_first_usedId)\n                    self.serial = self.mmcif_first_serial\n                    # regardless of its appearance, current entry now is regarded as the second entry\n                    self.mmcif[\"_entry\"][\"id\"] = [ self.mmcif[\"_entry\"][\"id\"][0], title ]\n                else:\n                    # otherwise continue to add entry\n                    self.mmcif[\"_entry\"][\"id\"].append(title)\n            else:\n                # you got here as the second entry\n                # save the first entry before adding the second entry\n                self.mmcif_first = copy.deepcopy(self.mmcif)\n                self.mmcif_first_usedId = copy.deepcopy(self.usedId)\n                self.mmcif_first_serial = self.serial\n                # change to a list type\n                self.mmcif[\"_entry\"][\"id\"] = [ self.mmcif[\"_entry\"][\"id\"], title ]\n        else:\n            # regular string type\n            self.mmcif[\"_entry\"] = { \"id\" : title }\n\n\n    def append_atom_site(self, \n                        group_PDB, id, \n                        type_symbol, \n                        label_atom_id, \n                        label_alt_id, \n                        label_comp_id,\n                        label_asym_id, \n                        label_entity_id, \n                        label_seq_id, \n                        pdbx_PDB_ins_code, \n                        Cartn_x, \n                        Cartn_y, \n                        Cartn_z,\n                        occupancy, \n                        B_iso_or_equiv, \n                        pdbx_formal_charge, \n                        auth_seq_id, \n                        auth_comp_id, \n                        auth_asym_id, \n                        auth_atom_id, \n                        pdbx_PDB_model_num):\n\n        \"\"\" add mmcif _atom_site \"\"\"\n\n        if self.mmcif[\"_atom_site\"] :\n            self.mmcif[\"_atom_site\"][\"group_PDB\"].append(group_PDB)\n            self.mmcif[\"_atom_site\"][\"id\"].append(id)\n            self.mmcif[\"_atom_site\"][\"type_symbol\"].append(type_symbol)\n            self.mmcif[\"_atom_site\"][\"label_atom_id\"].append(label_atom_id)\n            self.mmcif[\"_atom_site\"][\"label_alt_id\"].append(label_alt_id)\n            self.mmcif[\"_atom_site\"][\"label_comp_id\"].append(label_comp_id)\n            self.mmcif[\"_atom_site\"][\"label_asym_id\"].append(label_asym_id)\n            self.mmcif[\"_atom_site\"][\"label_entity_id\"].append(label_entity_id)\n            self.mmcif[\"_atom_site\"][\"label_seq_id\"].append(label_seq_id)\n            self.mmcif[\"_atom_site\"][\"pdbx_PDB_ins_code\"].append(pdbx_PDB_ins_code)\n            self.mmcif[\"_atom_site\"][\"Cartn_x\"].append(Cartn_x)\n            self.mmcif[\"_atom_site\"][\"Cartn_y\"].append(Cartn_y)\n            self.mmcif[\"_atom_site\"][\"Cartn_z\"].append(Cartn_z)\n            self.mmcif[\"_atom_site\"][\"occupancy\"].append(occupancy)\n            self.mmcif[\"_atom_site\"][\"B_iso_or_equiv\"].append(B_iso_or_equiv)\n            self.mmcif[\"_atom_site\"][\"pdbx_formal_charge\"].append(pdbx_formal_charge)\n            self.mmcif[\"_atom_site\"][\"auth_seq_id\"].append(auth_seq_id)\n            self.mmcif[\"_atom_site\"][\"auth_comp_id\"].append(auth_comp_id)\n            self.mmcif[\"_atom_site\"][\"auth_asym_id\"].append(auth_asym_id)\n            self.mmcif[\"_atom_site\"][\"auth_atom_id\"].append(auth_atom_id)\n            self.mmcif[\"_atom_site\"][\"pdbx_PDB_model_num\"].append(pdbx_PDB_model_num)\n        else:\n            self.mmcif[\"_atom_site\"] = {\n                \"group_PDB\" : [ group_PDB ],\n                \"id\" : [ id ],\n                \"type_symbol\" : [ type_symbol ],\n                \"label_atom_id\" : [ label_atom_id ],\n                \"label_alt_id\" : [ label_alt_id ],\n                \"label_comp_id\" : [ label_comp_id ],\n                \"label_asym_id\" : [ label_asym_id ],\n                \"label_entity_id\" : [ label_entity_id ],\n                \"label_seq_id\" : [ label_seq_id ],\n                \"pdbx_PDB_ins_code\" : [ pdbx_PDB_ins_code ],\n                \"Cartn_x\" : [ Cartn_x ],\n                \"Cartn_y\" : [ Cartn_y ],\n                \"Cartn_z\" : [ Cartn_z ],\n                \"occupancy\" : [ occupancy ],\n                \"B_iso_or_equiv\" : [ B_iso_or_equiv ],\n                \"pdbx_formal_charge\" : [ pdbx_formal_charge ],\n                \"auth_seq_id\" : [ auth_seq_id ],\n                \"auth_comp_id\" : [ auth_comp_id ],\n                \"auth_asym_id\" : [ auth_asym_id ],\n                \"auth_atom_id\" : [ auth_atom_id ],\n                \"pdbx_PDB_model_num\" : [ pdbx_PDB_model_num ],\n            }\n\n\n    def append_chem_comp_bond(self, chem_comp_id, i, j, k):\n        \"\"\" add chem_comp_bond \"\"\"\n        p = self.mmcif[\"_atom_site\"][\"label_atom_id\"][self.mmcif[\"_atom_site\"][\"id\"].index(i)]\n        q = self.mmcif[\"_atom_site\"][\"label_atom_id\"][self.mmcif[\"_atom_site\"][\"id\"].index(j)]\n        if self.mmcif[\"_chem_comp_bond\"]:\n            self.mmcif[\"_chem_comp_bond\"][\"comp_id\"].append(chem_comp_id)\n            self.mmcif[\"_chem_comp_bond\"][\"atom_id_1\"].append(p)\n            self.mmcif[\"_chem_comp_bond\"][\"atom_id_2\"].append(q)\n            self.mmcif[\"_chem_comp_bond\"][\"value_order\"].append(k)\n        else:\n            self.mmcif[\"_chem_comp_bond\"] = {\n                \"comp_id\" : [ chem_comp_id ],\n                \"atom_id_1\" : [ p ],\n                \"atom_id_2\" : [ q ],\n                \"value_order\" : [ k ],\n            }\n\n\n    def new_chem_comp(self):\n        \"\"\" start a new chem_comp entry \"\"\"\n        if not type(self.mmcif[\"_entry\"][\"id\"]) == list or len(self.mmcif[\"_entry\"][\"id\"]) &lt;= 2:\n            self.chem_comp_id = \"LIG\"\n        else:\n            self.chem_comp_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(3))\n        self.chem_comp_chainId = [ c for c in string.ascii_uppercase if not (c in self.usedId)][0]\n        self.chem_comp_resSeq = 100\n        self.usedId[self.chem_comp_chainId] = []\n        return self.chem_comp_chainId, self.chem_comp_resSeq, self.chem_comp_id\n\n\n    def new_chem_comp_atom(self, obj, element):\n        \"\"\" create and return unique atom name \"\"\"\n        if \"s_m_pdb_atom_name\" in obj:\n            atom_name = obj[\"s_m_pdb_atom_name\"].strip()\n        else:\n            atom_name = \"{}{}\".format(element,1)\n        if not (atom_name in self.usedId[self.chem_comp_chainId]):\n            self.usedId[self.chem_comp_chainId].append(atom_name)\n            return atom_name\n        else:\n            for i in range(1,10000):\n                new_name = \"{}{}\".format(element,i)\n                if not (new_name in self.usedId[self.chem_comp_chainId]):\n                    self.usedId[self.chem_comp_chainId].append(new_name)\n                    return new_name\n\n\n    def value_or_default(self, obj, k, default):\n        \"\"\" return value or default \"\"\"\n        v = None\n        if k in obj:\n            if type(obj[k]) == str:\n                v = obj[k].strip()\n        if v is None:\n            return default\n        else:\n            return v\n\n\n    def convert_to_mmcif(self):\n        token = None\n        entity_id = 0\n        for line in self.maesto_file:\n            line = line.strip()\n\n            if not line or line.startswith(\"#\"): \n                continue\n\n            # f_m_ct block\n            if line.startswith(\"f_m_ct {\"):\n                token = 'f_m_ct_key'\n                natoms = 0\n                nbonds = 0\n                entity_id += 1\n                k = []\n                continue\n            if token == 'f_m_ct_key':\n                if line.startswith(\":::\"): # end of f_m_ct key block\n                    n = len(k)\n                    token = 'f_m_ct_val'\n                    v = []\n                    continue\n                k.append(line)\n            if token == 'f_m_ct_val':\n                v.append(line)\n                if len(v) == n:\n                    data = dict(zip(k,v))\n                    if \"s_lp_Variant\" in data:\n                        self.title = data['s_lp_Variant'].replace('\"','').replace(\"'\",\"\")\n                    else:\n                        self.title = data['s_m_title'].replace('\"','').replace(\"'\",\"\")\n                    self.append_entry(self.title)\n                    token = None\n\n\n            # m_atom block\n            if line.startswith(\"m_atom\") :\n                natoms = int(self.count.findall(line)[0])\n                token = 'm_atom_key'\n                k = ['i_atom_index'] # 1st column is atom_index\n                continue\n            if token == 'm_atom_key':\n                if line.startswith(\":::\"):\n                    token = 'm_atom_val'\n                    nv = 0\n                    m_atom = {}\n                    m_atom_resName = {}\n                    continue\n                k.append(line)\n            if token == 'm_atom_val':\n                v = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n                data = dict(zip(k,v))\n\n                # build hierarchical structure of chain/ resSeq/ resName\n                chainId = self.value_or_default(data,\"s_m_chain_name\", \"A\")\n                resSeq = int(self.value_or_default(data, \"i_m_residue_number\", 1))\n                resName = self.value_or_default(data, \"s_m_pdb_residue_name\", \"?\")\n                if resName in self.std_rename:\n                    resName = self.std_rename[resName]\n                if not chainId in m_atom:\n                    m_atom[chainId] = {}\n                if not resSeq in m_atom[chainId]:\n                    m_atom[chainId][resSeq] = {}\n                if not resName in m_atom[chainId][resSeq]:\n                    m_atom[chainId][resSeq][resName] = []\n                m_atom[chainId][resSeq][resName].append(data)\n                m_atom_resName[int(data[\"i_atom_index\"])] = resName\n\n                nv += 1\n                if nv == natoms: # end of m_atom block\n                    token = None\n\n            \"\"\" m_bond block \"\"\"\n            if line.startswith(\"m_bond\") :\n                nbonds = int(self.count.findall(line)[0])\n                token = 'm_bond_key'\n                k = ['i_bond_index']\n                continue\n            if token == 'm_bond_key':\n                if line.startswith(\":::\"): # end of m_bond key block\n                    token = 'm_bond_val'\n                    nv = 0\n                    m_bond = {}\n                    continue\n                k.append(line)\n            if token == 'm_bond_val':\n                v = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n                data = dict(zip(k,v))\n\n                # build bond connectivity\n                p = int(data[\"i_m_from\"]) \n                q = int(data[\"i_m_to\"]) \n                r = int(data[\"i_m_order\"])\n                if p in m_bond:\n                    m_bond[p][q] = r\n                else:\n                    m_bond[p] = {q:r}\n                if q in m_bond:\n                    m_bond[q][p] = r\n                else:\n                    m_bond[q] = {p:r}\n\n                nv += 1\n                if nv == nbonds: # m_bond block ends\n                    token = None\n\n                    # create mmcif _atom_site\n                    for chainId_ in sorted(m_atom):\n                        for resSeq_ in sorted(m_atom[chainId_]):\n                            for resName_ in sorted(m_atom[chainId_][resSeq_]):\n                                if resName_ in self.std_residues:\n                                    group_PDB = \"ATOM\"\n                                    chainId, resSeq, resName = chainId_, resSeq_, resName_\n                                else:\n                                    group_PDB = \"HETATM\"\n                                    # check if new_chem_comp is necessary\n                                    this_residue = [ int(d[\"i_atom_index\"]) for d in m_atom[chainId_][resSeq_][resName_] ]\n                                    need_new_chem_comp = True\n                                    for p_ in this_residue:\n                                        for q_, bond_order in m_bond[p_].items():\n                                            if  (not (q_ in this_residue)) and \\\n                                                (not (m_atom_resName[q_] in self.std_residues)) and \\\n                                                (q_ in self.iamap):\n                                                # do not create another chem_comp\n                                                need_new_chem_comp = False\n                                                q, chainId, resSeq, resName = self.iamap[q_]\n                                                break\n                                    if need_new_chem_comp:\n                                        chainId, resSeq, resName = self.new_chem_comp()\n\n                                # go through all atoms within the same residue\n                                for d in m_atom[chainId_][resSeq_][resName_]:\n                                    self.serial += 1\n                                    self.iamap[int(d[\"i_atom_index\"])] = (self.serial, chainId, resSeq, resName)\n                                    element = self.atomic_symbol[int(d[\"i_m_atomic_number\"])]\n                                    if group_PDB == \"ATOM\":\n                                        name = self.value_or_default(d,\"s_m_pdb_atom_name\", \"?\")\n                                    else:\n                                        name = self.new_chem_comp_atom(d, element) \n                                    x = float(d[\"r_m_x_coord\"])\n                                    y = float(d[\"r_m_y_coord\"])\n                                    z = float(d[\"r_m_z_coord\"])\n                                    occupancy = float(self.value_or_default(d,\"r_m_pdb_occupancy\",1))\n                                    bfactor = float(self.value_or_default(d,\"r_m_pdb_tfactor\", 0))\n                                    formal_charge = int(self.value_or_default(d,\"i_m_formal_charge\", 0))\n                                    self.append_atom_site(\n                                        group_PDB = group_PDB, \n                                        id = self.serial,\n                                        type_symbol = element,\n                                        label_atom_id = name,\n                                        label_alt_id = \".\",\n                                        label_comp_id = resName,\n                                        label_asym_id = chainId,\n                                        label_entity_id = entity_id,\n                                        label_seq_id = resSeq,\n                                        pdbx_PDB_ins_code = \"?\",\n                                        Cartn_x = x,\n                                        Cartn_y = y,\n                                        Cartn_z = z,\n                                        occupancy = occupancy,\n                                        B_iso_or_equiv = bfactor,\n                                        pdbx_formal_charge = formal_charge,\n                                        auth_seq_id = resSeq,\n                                        auth_comp_id = resName,\n                                        auth_asym_id = chainId,\n                                        auth_atom_id = name,\n                                        pdbx_PDB_model_num = 1,\n                                    )\n\n                    # create mmcif _chem_comp_bond\n                    for chainId_ in sorted(m_atom):\n                        for resSeq_ in sorted(m_atom[chainId_]):\n                            for resName_ in sorted(m_atom[chainId_][resSeq_]):\n                                if not (resName_ in self.std_residues): # HETATM\n                                    for d in m_atom[chainId_][resSeq_][resName_]:\n                                        p_ = int(d[\"i_atom_index\"])\n                                        p, p_chainId, p_resSeq, p_resName = self.iamap[p_]\n                                        if p_ in m_bond:\n                                            for q_, bond_order in m_bond[p_].items():\n                                                q, q_chainId, q_resSeq, q_resName = self.iamap[q_]\n                                                self.append_chem_comp_bond(p_resName, p, q, bond_order)\n\n        self.maesto_file.close()\n        self.write_mmcif()\n\n\n    def write_mmcif(self):\n        \"\"\" write to .cif file \"\"\"\n        output = \"{}.cif\".format(self.prefix)\n        print(\"writing to {}\".format(output))\n\n        cifo = CifFileWriter(output)\n        # clean up undefined dictionary\n        # force to copy a list to avoid \n        # RuntimeError: dictionary changed size during iteration\n        for k in list(self.mmcif): \n            if not self.mmcif[k]:\n                del self.mmcif[k]\n\n        cifo.write({ \"desmondtools\" : self.mmcif })\n</code></pre>"},{"location":"index.html#desmondtools.Maestro-attributes","title":"Attributes","text":""},{"location":"index.html#desmondtools.Maestro.atomic_symbol","title":"<code>atomic_symbol = {1: 'H', 2: 'He', 3: 'Li', 4: 'Be', 5: 'B', 6: 'C', 7: 'N', 8: 'O', 9: 'F', 10: 'Ne', 11: 'Na', 12: 'Mg', 13: 'Al', 14: 'Si', 15: 'P', 16: 'S', 17: 'Cl', 18: 'Ar', 19: 'K', 20: 'Ca', 21: 'Sc', 22: 'Ti', 23: 'V', 24: 'Cr', 25: 'Mn', 26: 'Fe', 27: 'Co', 28: 'Ni', 29: 'Cu', 30: 'Zn', 31: 'Ga', 32: 'Ge', 33: 'As', 34: 'Se', 35: 'Br', 36: 'Kr', 37: 'Rb', 38: 'Sr', 39: 'Y', 40: 'Zr', 41: 'Nb', 42: 'Mo', 43: 'Tc', 44: 'Ru', 45: 'Rh', 46: 'Pd', 47: 'Ag', 48: 'Cd', 49: 'In', 50: 'Sn', 51: 'Sb', 52: 'Te', 53: 'I', 54: 'Xe', 55: 'Cs', 56: 'Ba', 57: 'La', 58: 'Ce', 59: 'Pr', 60: 'Nd', 61: 'Pm', 62: 'Sm', 63: 'Eu', 64: 'Gd', 65: 'Tb', 66: 'Dy', 67: 'Ho', 68: 'Er', 69: 'Tm', 70: 'Yb', 71: 'Lu', 72: 'Hf', 73: 'Ta', 74: 'W', 75: 'Re', 76: 'Os', 77: 'Ir', 78: 'Pt', 79: 'Au', 80: 'Hg', 81: 'Tl', 82: 'Pb', 83: 'Bi', 84: 'Po', 85: 'At', 86: 'Rn', 87: 'Fr', 88: 'Ra', 89: 'Ac', 90: 'Th', 91: 'Pa', 92: 'U', 93: 'Np', 94: 'Pu', 95: 'Am', 96: 'Cm', 97: 'Bk', 98: 'Cf', 99: 'Es', 100: 'Fm', 101: 'Md', 102: 'No', 103: 'Lr', 104: 'Rf', 105: 'Db', 106: 'Sg', 107: 'Bh', 108: 'Hs', 109: 'Mt', 110: 'Ds', 111: 'Rg', 112: 'Cn', 113: 'Nh', 114: 'Fl', 115: 'Mc', 116: 'Lv', 117: 'Ts', 118: 'Og'}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.count","title":"<code>count = re.compile('\\\\[(\\\\d+)\\\\]')</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.iamap","title":"<code>iamap = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.maesto_file","title":"<code>maesto_file = gzip.open(filename, 'rt')</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.max_two_entries","title":"<code>max_two_entries = max_two_entries</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.mmcif","title":"<code>mmcif = {'_entry': None, '_chem_comp_bond': None, '_atom_site': None}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.prefix","title":"<code>prefix = filename.replace('.maegz', '')</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.serial","title":"<code>serial = 0</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.std_rename","title":"<code>std_rename = {'URI': 'URA', 'CYX': 'CYS', 'CYM': 'CYS', 'HID': 'HIS', 'HIE': 'HIS', 'HIP': 'HIS'}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.std_residues","title":"<code>std_residues = ['ADE', 'GUA', 'CYT', 'URA', 'THY', 'ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU', 'GLY', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE', 'PRO', 'SER', 'THR', 'TRP', 'TYR', 'VAL']</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.title","title":"<code>title = ''</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.usedId","title":"<code>usedId = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro-functions","title":"Functions","text":""},{"location":"index.html#desmondtools.Maestro.__init__","title":"<code>__init__(filename, max_two_entries=True)</code>","text":"<p>initialize</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def __init__(self, filename:str, max_two_entries:bool=True) -&gt; None:\n    \"\"\" initialize \"\"\"\n\n    if filename.endswith('.maegz'):\n        self.prefix = filename.replace(\".maegz\",\"\")\n        self.maesto_file = gzip.open(filename, \"rt\")\n    elif filename.endswith('.mae.gz'):\n        self.prefix = filename.replace(\".mae.gz\",\"\")\n        self.maesto_file = gzip.open(filename, \"rt\")\n    elif filename.endswith('.mae'):\n        self.prefix = filename.replace(\".mae\",\"\")\n        self.maesto_file = open(filename, \"rt\")\n    else:\n        print(\".mae, .mae.gz, or .maegz are expected\")\n        sys.exit(0)\n\n    # standard DNA/RNA/Protein\n    self.std_residues = [\n        \"ADE\", \"GUA\", \"CYT\", \"URA\", \"THY\",\n        \"ALA\", \"ARG\", \"ASN\", \"ASP\", \"CYS\", \"GLN\", \"GLU\", \"GLY\", \"HIS\", \"ILE\",\n        \"LEU\", \"LYS\", \"MET\", \"PHE\", \"PRO\", \"SER\", \"THR\", \"TRP\", \"TYR\", \"VAL\",\n    ]\n\n    # conversion to standard residue name\n    self.std_rename = {\n        \"URI\" : \"URA\",\n        \"CYX\" : \"CYS\", # disulfide-bonded\n        \"CYM\" : \"CYS\", # deprotonated (- charge) and/or bound to metal atoms\n        \"HID\" : \"HIS\", # protonated at delta position\n        \"HIE\" : \"HIS\", # protonated at epsilon\n        \"HIP\" : \"HIS\", # protonated at both delta and epsilon\n    } \n\n    self.atomic_symbol = {\n         1 : \"H\",   2 : \"He\",  3 : \"Li\",  4 : \"Be\",  5 : \"B\",   6 : \"C\",   7 : \"N\",   8 : \"O\",   9 : \"F\",  10 : \"Ne\",\n        11 : \"Na\", 12 : \"Mg\", 13 : \"Al\", 14 : \"Si\", 15 : \"P\",  16 : \"S\",  17 : \"Cl\", 18 : \"Ar\", 19 : \"K\",  20 : \"Ca\",\n        21 : \"Sc\", 22 : \"Ti\", 23 : \"V\",  24 : \"Cr\", 25 : \"Mn\", 26 : \"Fe\", 27 : \"Co\", 28 : \"Ni\", 29 : \"Cu\", 30 : \"Zn\",\n        31 : \"Ga\", 32 : \"Ge\", 33 : \"As\", 34 : \"Se\", 35 : \"Br\", 36 : \"Kr\", 37 : \"Rb\", 38 : \"Sr\", 39 : \"Y\",  40 : \"Zr\",\n        41 : \"Nb\", 42 : \"Mo\", 43 : \"Tc\", 44 : \"Ru\", 45 : \"Rh\", 46 : \"Pd\", 47 : \"Ag\", 48 : \"Cd\", 49 : \"In\", 50 : \"Sn\",\n        51 : \"Sb\", 52 : \"Te\", 53 : \"I\",  54 : \"Xe\", 55 : \"Cs\", 56 : \"Ba\", 57 : \"La\", 58 : \"Ce\", 59 : \"Pr\", 60 : \"Nd\",\n        61 : \"Pm\", 62 : \"Sm\", 63 : \"Eu\", 64 : \"Gd\", 65 : \"Tb\", 66 : \"Dy\", 67 : \"Ho\", 68 : \"Er\", 69 : \"Tm\", 70 : \"Yb\",\n        71 : \"Lu\", 72 : \"Hf\", 73 : \"Ta\", 74 : \"W\",  75 : \"Re\", 76 : \"Os\", 77 : \"Ir\", 78 : \"Pt\", 79 : \"Au\", 80 : \"Hg\",\n        81 : \"Tl\", 82 : \"Pb\", 83 : \"Bi\", 84 : \"Po\", 85 : \"At\", 86 : \"Rn\", 87 : \"Fr\", 88 : \"Ra\", 89 : \"Ac\", 90 : \"Th\",\n        91 : \"Pa\", 92 : \"U\",  93 : \"Np\", 94 : \"Pu\", 95 : \"Am\", 96 : \"Cm\", 97 : \"Bk\", 98 : \"Cf\", 99 : \"Es\", 100: \"Fm\",\n        101: \"Md\", 102: \"No\", 103: \"Lr\", 104: \"Rf\", 105: \"Db\", 106: \"Sg\", 107: \"Bh\", 108: \"Hs\", 109: \"Mt\", 110: \"Ds\",\n        111: \"Rg\", 112: \"Cn\", 113: \"Nh\", 114: \"Fl\", 115: \"Mc\", 116: \"Lv\", 117: \"Ts\", 118: \"Og\",\n    }\n\n    self.max_two_entries = max_two_entries\n    self.count = re.compile(r'\\[(\\d+)\\]')\n    self.title = \"\"\n    self.serial = 0\n    self.usedId = {}\n    self.mmcif = {\n        \"_entry\": None, \n        \"_chem_comp_bond\": None, \n        \"_atom_site\": None,\n        } # mmcif-like object\n    self.iamap = {}\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.append_atom_site","title":"<code>append_atom_site(group_PDB, id, type_symbol, label_atom_id, label_alt_id, label_comp_id, label_asym_id, label_entity_id, label_seq_id, pdbx_PDB_ins_code, Cartn_x, Cartn_y, Cartn_z, occupancy, B_iso_or_equiv, pdbx_formal_charge, auth_seq_id, auth_comp_id, auth_asym_id, auth_atom_id, pdbx_PDB_model_num)</code>","text":"<p>add mmcif _atom_site</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def append_atom_site(self, \n                    group_PDB, id, \n                    type_symbol, \n                    label_atom_id, \n                    label_alt_id, \n                    label_comp_id,\n                    label_asym_id, \n                    label_entity_id, \n                    label_seq_id, \n                    pdbx_PDB_ins_code, \n                    Cartn_x, \n                    Cartn_y, \n                    Cartn_z,\n                    occupancy, \n                    B_iso_or_equiv, \n                    pdbx_formal_charge, \n                    auth_seq_id, \n                    auth_comp_id, \n                    auth_asym_id, \n                    auth_atom_id, \n                    pdbx_PDB_model_num):\n\n    \"\"\" add mmcif _atom_site \"\"\"\n\n    if self.mmcif[\"_atom_site\"] :\n        self.mmcif[\"_atom_site\"][\"group_PDB\"].append(group_PDB)\n        self.mmcif[\"_atom_site\"][\"id\"].append(id)\n        self.mmcif[\"_atom_site\"][\"type_symbol\"].append(type_symbol)\n        self.mmcif[\"_atom_site\"][\"label_atom_id\"].append(label_atom_id)\n        self.mmcif[\"_atom_site\"][\"label_alt_id\"].append(label_alt_id)\n        self.mmcif[\"_atom_site\"][\"label_comp_id\"].append(label_comp_id)\n        self.mmcif[\"_atom_site\"][\"label_asym_id\"].append(label_asym_id)\n        self.mmcif[\"_atom_site\"][\"label_entity_id\"].append(label_entity_id)\n        self.mmcif[\"_atom_site\"][\"label_seq_id\"].append(label_seq_id)\n        self.mmcif[\"_atom_site\"][\"pdbx_PDB_ins_code\"].append(pdbx_PDB_ins_code)\n        self.mmcif[\"_atom_site\"][\"Cartn_x\"].append(Cartn_x)\n        self.mmcif[\"_atom_site\"][\"Cartn_y\"].append(Cartn_y)\n        self.mmcif[\"_atom_site\"][\"Cartn_z\"].append(Cartn_z)\n        self.mmcif[\"_atom_site\"][\"occupancy\"].append(occupancy)\n        self.mmcif[\"_atom_site\"][\"B_iso_or_equiv\"].append(B_iso_or_equiv)\n        self.mmcif[\"_atom_site\"][\"pdbx_formal_charge\"].append(pdbx_formal_charge)\n        self.mmcif[\"_atom_site\"][\"auth_seq_id\"].append(auth_seq_id)\n        self.mmcif[\"_atom_site\"][\"auth_comp_id\"].append(auth_comp_id)\n        self.mmcif[\"_atom_site\"][\"auth_asym_id\"].append(auth_asym_id)\n        self.mmcif[\"_atom_site\"][\"auth_atom_id\"].append(auth_atom_id)\n        self.mmcif[\"_atom_site\"][\"pdbx_PDB_model_num\"].append(pdbx_PDB_model_num)\n    else:\n        self.mmcif[\"_atom_site\"] = {\n            \"group_PDB\" : [ group_PDB ],\n            \"id\" : [ id ],\n            \"type_symbol\" : [ type_symbol ],\n            \"label_atom_id\" : [ label_atom_id ],\n            \"label_alt_id\" : [ label_alt_id ],\n            \"label_comp_id\" : [ label_comp_id ],\n            \"label_asym_id\" : [ label_asym_id ],\n            \"label_entity_id\" : [ label_entity_id ],\n            \"label_seq_id\" : [ label_seq_id ],\n            \"pdbx_PDB_ins_code\" : [ pdbx_PDB_ins_code ],\n            \"Cartn_x\" : [ Cartn_x ],\n            \"Cartn_y\" : [ Cartn_y ],\n            \"Cartn_z\" : [ Cartn_z ],\n            \"occupancy\" : [ occupancy ],\n            \"B_iso_or_equiv\" : [ B_iso_or_equiv ],\n            \"pdbx_formal_charge\" : [ pdbx_formal_charge ],\n            \"auth_seq_id\" : [ auth_seq_id ],\n            \"auth_comp_id\" : [ auth_comp_id ],\n            \"auth_asym_id\" : [ auth_asym_id ],\n            \"auth_atom_id\" : [ auth_atom_id ],\n            \"pdbx_PDB_model_num\" : [ pdbx_PDB_model_num ],\n        }\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.append_chem_comp_bond","title":"<code>append_chem_comp_bond(chem_comp_id, i, j, k)</code>","text":"<p>add chem_comp_bond</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def append_chem_comp_bond(self, chem_comp_id, i, j, k):\n    \"\"\" add chem_comp_bond \"\"\"\n    p = self.mmcif[\"_atom_site\"][\"label_atom_id\"][self.mmcif[\"_atom_site\"][\"id\"].index(i)]\n    q = self.mmcif[\"_atom_site\"][\"label_atom_id\"][self.mmcif[\"_atom_site\"][\"id\"].index(j)]\n    if self.mmcif[\"_chem_comp_bond\"]:\n        self.mmcif[\"_chem_comp_bond\"][\"comp_id\"].append(chem_comp_id)\n        self.mmcif[\"_chem_comp_bond\"][\"atom_id_1\"].append(p)\n        self.mmcif[\"_chem_comp_bond\"][\"atom_id_2\"].append(q)\n        self.mmcif[\"_chem_comp_bond\"][\"value_order\"].append(k)\n    else:\n        self.mmcif[\"_chem_comp_bond\"] = {\n            \"comp_id\" : [ chem_comp_id ],\n            \"atom_id_1\" : [ p ],\n            \"atom_id_2\" : [ q ],\n            \"value_order\" : [ k ],\n        }\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.append_entry","title":"<code>append_entry(title)</code>","text":"<p>start a new entry</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def append_entry(self, title):\n    \"\"\" start a new entry \"\"\"\n\n    if self.mmcif[\"_entry\"]:\n        if type(self.mmcif[\"_entry\"][\"id\"]) == list:\n            # you got here as the third and later entry\n            if self.max_two_entries:\n                # write out last two entries\n                self.write_mmcif()\n                # return to the state in which only the first entry was defined\n                self.mmcif = copy.deepcopy(self.mmcif_first)\n                self.usedId = copy.deepcopy(self.mmcif_first_usedId)\n                self.serial = self.mmcif_first_serial\n                # regardless of its appearance, current entry now is regarded as the second entry\n                self.mmcif[\"_entry\"][\"id\"] = [ self.mmcif[\"_entry\"][\"id\"][0], title ]\n            else:\n                # otherwise continue to add entry\n                self.mmcif[\"_entry\"][\"id\"].append(title)\n        else:\n            # you got here as the second entry\n            # save the first entry before adding the second entry\n            self.mmcif_first = copy.deepcopy(self.mmcif)\n            self.mmcif_first_usedId = copy.deepcopy(self.usedId)\n            self.mmcif_first_serial = self.serial\n            # change to a list type\n            self.mmcif[\"_entry\"][\"id\"] = [ self.mmcif[\"_entry\"][\"id\"], title ]\n    else:\n        # regular string type\n        self.mmcif[\"_entry\"] = { \"id\" : title }\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.convert_to_mmcif","title":"<code>convert_to_mmcif()</code>","text":"Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def convert_to_mmcif(self):\n    token = None\n    entity_id = 0\n    for line in self.maesto_file:\n        line = line.strip()\n\n        if not line or line.startswith(\"#\"): \n            continue\n\n        # f_m_ct block\n        if line.startswith(\"f_m_ct {\"):\n            token = 'f_m_ct_key'\n            natoms = 0\n            nbonds = 0\n            entity_id += 1\n            k = []\n            continue\n        if token == 'f_m_ct_key':\n            if line.startswith(\":::\"): # end of f_m_ct key block\n                n = len(k)\n                token = 'f_m_ct_val'\n                v = []\n                continue\n            k.append(line)\n        if token == 'f_m_ct_val':\n            v.append(line)\n            if len(v) == n:\n                data = dict(zip(k,v))\n                if \"s_lp_Variant\" in data:\n                    self.title = data['s_lp_Variant'].replace('\"','').replace(\"'\",\"\")\n                else:\n                    self.title = data['s_m_title'].replace('\"','').replace(\"'\",\"\")\n                self.append_entry(self.title)\n                token = None\n\n\n        # m_atom block\n        if line.startswith(\"m_atom\") :\n            natoms = int(self.count.findall(line)[0])\n            token = 'm_atom_key'\n            k = ['i_atom_index'] # 1st column is atom_index\n            continue\n        if token == 'm_atom_key':\n            if line.startswith(\":::\"):\n                token = 'm_atom_val'\n                nv = 0\n                m_atom = {}\n                m_atom_resName = {}\n                continue\n            k.append(line)\n        if token == 'm_atom_val':\n            v = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n            data = dict(zip(k,v))\n\n            # build hierarchical structure of chain/ resSeq/ resName\n            chainId = self.value_or_default(data,\"s_m_chain_name\", \"A\")\n            resSeq = int(self.value_or_default(data, \"i_m_residue_number\", 1))\n            resName = self.value_or_default(data, \"s_m_pdb_residue_name\", \"?\")\n            if resName in self.std_rename:\n                resName = self.std_rename[resName]\n            if not chainId in m_atom:\n                m_atom[chainId] = {}\n            if not resSeq in m_atom[chainId]:\n                m_atom[chainId][resSeq] = {}\n            if not resName in m_atom[chainId][resSeq]:\n                m_atom[chainId][resSeq][resName] = []\n            m_atom[chainId][resSeq][resName].append(data)\n            m_atom_resName[int(data[\"i_atom_index\"])] = resName\n\n            nv += 1\n            if nv == natoms: # end of m_atom block\n                token = None\n\n        \"\"\" m_bond block \"\"\"\n        if line.startswith(\"m_bond\") :\n            nbonds = int(self.count.findall(line)[0])\n            token = 'm_bond_key'\n            k = ['i_bond_index']\n            continue\n        if token == 'm_bond_key':\n            if line.startswith(\":::\"): # end of m_bond key block\n                token = 'm_bond_val'\n                nv = 0\n                m_bond = {}\n                continue\n            k.append(line)\n        if token == 'm_bond_val':\n            v = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n            data = dict(zip(k,v))\n\n            # build bond connectivity\n            p = int(data[\"i_m_from\"]) \n            q = int(data[\"i_m_to\"]) \n            r = int(data[\"i_m_order\"])\n            if p in m_bond:\n                m_bond[p][q] = r\n            else:\n                m_bond[p] = {q:r}\n            if q in m_bond:\n                m_bond[q][p] = r\n            else:\n                m_bond[q] = {p:r}\n\n            nv += 1\n            if nv == nbonds: # m_bond block ends\n                token = None\n\n                # create mmcif _atom_site\n                for chainId_ in sorted(m_atom):\n                    for resSeq_ in sorted(m_atom[chainId_]):\n                        for resName_ in sorted(m_atom[chainId_][resSeq_]):\n                            if resName_ in self.std_residues:\n                                group_PDB = \"ATOM\"\n                                chainId, resSeq, resName = chainId_, resSeq_, resName_\n                            else:\n                                group_PDB = \"HETATM\"\n                                # check if new_chem_comp is necessary\n                                this_residue = [ int(d[\"i_atom_index\"]) for d in m_atom[chainId_][resSeq_][resName_] ]\n                                need_new_chem_comp = True\n                                for p_ in this_residue:\n                                    for q_, bond_order in m_bond[p_].items():\n                                        if  (not (q_ in this_residue)) and \\\n                                            (not (m_atom_resName[q_] in self.std_residues)) and \\\n                                            (q_ in self.iamap):\n                                            # do not create another chem_comp\n                                            need_new_chem_comp = False\n                                            q, chainId, resSeq, resName = self.iamap[q_]\n                                            break\n                                if need_new_chem_comp:\n                                    chainId, resSeq, resName = self.new_chem_comp()\n\n                            # go through all atoms within the same residue\n                            for d in m_atom[chainId_][resSeq_][resName_]:\n                                self.serial += 1\n                                self.iamap[int(d[\"i_atom_index\"])] = (self.serial, chainId, resSeq, resName)\n                                element = self.atomic_symbol[int(d[\"i_m_atomic_number\"])]\n                                if group_PDB == \"ATOM\":\n                                    name = self.value_or_default(d,\"s_m_pdb_atom_name\", \"?\")\n                                else:\n                                    name = self.new_chem_comp_atom(d, element) \n                                x = float(d[\"r_m_x_coord\"])\n                                y = float(d[\"r_m_y_coord\"])\n                                z = float(d[\"r_m_z_coord\"])\n                                occupancy = float(self.value_or_default(d,\"r_m_pdb_occupancy\",1))\n                                bfactor = float(self.value_or_default(d,\"r_m_pdb_tfactor\", 0))\n                                formal_charge = int(self.value_or_default(d,\"i_m_formal_charge\", 0))\n                                self.append_atom_site(\n                                    group_PDB = group_PDB, \n                                    id = self.serial,\n                                    type_symbol = element,\n                                    label_atom_id = name,\n                                    label_alt_id = \".\",\n                                    label_comp_id = resName,\n                                    label_asym_id = chainId,\n                                    label_entity_id = entity_id,\n                                    label_seq_id = resSeq,\n                                    pdbx_PDB_ins_code = \"?\",\n                                    Cartn_x = x,\n                                    Cartn_y = y,\n                                    Cartn_z = z,\n                                    occupancy = occupancy,\n                                    B_iso_or_equiv = bfactor,\n                                    pdbx_formal_charge = formal_charge,\n                                    auth_seq_id = resSeq,\n                                    auth_comp_id = resName,\n                                    auth_asym_id = chainId,\n                                    auth_atom_id = name,\n                                    pdbx_PDB_model_num = 1,\n                                )\n\n                # create mmcif _chem_comp_bond\n                for chainId_ in sorted(m_atom):\n                    for resSeq_ in sorted(m_atom[chainId_]):\n                        for resName_ in sorted(m_atom[chainId_][resSeq_]):\n                            if not (resName_ in self.std_residues): # HETATM\n                                for d in m_atom[chainId_][resSeq_][resName_]:\n                                    p_ = int(d[\"i_atom_index\"])\n                                    p, p_chainId, p_resSeq, p_resName = self.iamap[p_]\n                                    if p_ in m_bond:\n                                        for q_, bond_order in m_bond[p_].items():\n                                            q, q_chainId, q_resSeq, q_resName = self.iamap[q_]\n                                            self.append_chem_comp_bond(p_resName, p, q, bond_order)\n\n    self.maesto_file.close()\n    self.write_mmcif()\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.new_chem_comp","title":"<code>new_chem_comp()</code>","text":"<p>start a new chem_comp entry</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def new_chem_comp(self):\n    \"\"\" start a new chem_comp entry \"\"\"\n    if not type(self.mmcif[\"_entry\"][\"id\"]) == list or len(self.mmcif[\"_entry\"][\"id\"]) &lt;= 2:\n        self.chem_comp_id = \"LIG\"\n    else:\n        self.chem_comp_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(3))\n    self.chem_comp_chainId = [ c for c in string.ascii_uppercase if not (c in self.usedId)][0]\n    self.chem_comp_resSeq = 100\n    self.usedId[self.chem_comp_chainId] = []\n    return self.chem_comp_chainId, self.chem_comp_resSeq, self.chem_comp_id\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.new_chem_comp_atom","title":"<code>new_chem_comp_atom(obj, element)</code>","text":"<p>create and return unique atom name</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def new_chem_comp_atom(self, obj, element):\n    \"\"\" create and return unique atom name \"\"\"\n    if \"s_m_pdb_atom_name\" in obj:\n        atom_name = obj[\"s_m_pdb_atom_name\"].strip()\n    else:\n        atom_name = \"{}{}\".format(element,1)\n    if not (atom_name in self.usedId[self.chem_comp_chainId]):\n        self.usedId[self.chem_comp_chainId].append(atom_name)\n        return atom_name\n    else:\n        for i in range(1,10000):\n            new_name = \"{}{}\".format(element,i)\n            if not (new_name in self.usedId[self.chem_comp_chainId]):\n                self.usedId[self.chem_comp_chainId].append(new_name)\n                return new_name\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.value_or_default","title":"<code>value_or_default(obj, k, default)</code>","text":"<p>return value or default</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def value_or_default(self, obj, k, default):\n    \"\"\" return value or default \"\"\"\n    v = None\n    if k in obj:\n        if type(obj[k]) == str:\n            v = obj[k].strip()\n    if v is None:\n        return default\n    else:\n        return v\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.write_mmcif","title":"<code>write_mmcif()</code>","text":"<p>write to .cif file</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def write_mmcif(self):\n    \"\"\" write to .cif file \"\"\"\n    output = \"{}.cif\".format(self.prefix)\n    print(\"writing to {}\".format(output))\n\n    cifo = CifFileWriter(output)\n    # clean up undefined dictionary\n    # force to copy a list to avoid \n    # RuntimeError: dictionary changed size during iteration\n    for k in list(self.mmcif): \n        if not self.mmcif[k]:\n            del self.mmcif[k]\n\n    cifo.write({ \"desmondtools\" : self.mmcif })\n</code></pre>"}]}