{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>DesmondTools have a set of command-line scripts and a python library written to make setting up the molecular dynamics simulations easier for Desmond.</p>"},{"location":"index.html#install","title":"Install","text":"<pre><code>$ pip install desmondtools\n</code></pre>"},{"location":"index.html#what-is-multisim-class","title":"What is Multisim Class?","text":"<p>The following code examples from <code>test/test_multisim.py</code> demonstrate the functionality of the Multisim class.</p> <pre><code>from desmondtools import Multisim\n\ndef test_Multisim_variable():\n    # parse_string returns ['barostat.tau']\n    o1 = Multisim.variable.parse_string(\"barostat.tau\")[0]\n    o2 = Multisim.variable.parse_string(\"barostat  .tau\")[0]\n    assert o1 == o2\n\n\ndef test_Multisim_expression_1():\n    i = \"task {} simulate { meta = [{a=1 b=3 c=[7 8 9]}] f = {} } simulate {n=2} simulate {n = 3}\"\n    D = Multisim(string=i).to_dot()\n    assert D.simulate[0].meta[0].b == str(3)\n    assert D.simulate[0].meta[0].c[1] == str(8)\n    assert D.simulate[-1].n == str(3)\n\n\ndef test_Multisim_expression_2():\n    i = \"simulate { effect_if = [[ a ] b ] }\"\n    D = Multisim(string=i).to_dot()\n    assert D.simulate.effect_if[0] == ['a']\n    assert D.simulate.effect_if[1] == 'b'\n\n\ndef test_Multisim_expression_3():\n    i = \"\"\"ensemble = {\n        brownie = {\n            delta_max = 0.1\n        }\n        class = NVT\n        method = Brownie\n        thermostat = {\n            tau = 1.0\n        }\n    }\"\"\"\n    D = Multisim(string=i)\n    assert D.dot.ensemble.brownie.delta_max == str(0.1)\n\n    # assert D.dot.ensemble.class == 'NVT'\n    #                       ^^^^^\n    # SyntaxError: invalid syntax\n    # 'class' is reserved word in python and raises SyntaxError\n    # use instead .['class']\n    assert D.dot.ensemble['class'] == 'NVT' # &lt;--- it does not raise SyntaxError\n\n    assert D.dot.ensemble.method == 'Brownie'\n    assert D.dot.ensemble.thermostat.tau == str(1.0)\n    D.write()\n\n\ndef test_Multisim_expression_4():\n    i = \"\"\"task {\n        task = \"desmond:auto\"\n    }\n    simulate {\n        title = \"NPT and no restraints, 24ps\"\n        effect_if = [[ \"@*.*.annealing\" ] 'annealing = off temperature = \"@*.*.temperature[0][0]\"' ]\n        time = 24\n        ensemble = {\n            class = NPT\n            method = Langevin\n            thermostat.tau = 0.1\n            barostat.tau = 2.0\n        }\n        eneseq.interval = 0.3\n        trajectory.center = solute\n    }\n    simulate {\n        meta = {\n            cv = [\n                { \n                    atom = [0 0 0 0] \n                    type = dihedral \n                    wall = 0  \n                    width = 5.0 \n                }\n            ]\n            cv_name = \"$JOBNAME$[_replica$REPLICA$].cvseq\"\n            first = 0.0\n            height = 0.03\n            interval = 0.09\n            name = \"$JOBNAME$[_replica$REPLICA$].kerseq\"\n        }\n    }\n    \"\"\"\n\n    D = Multisim(string=i)\n\n    assert len(D.dot.simulate[0].effect_if) == 2\n    assert len(D.dot.simulate[0].effect_if[0]) == 1\n    assert D.dot.simulate[0].ensemble.method == 'Langevin'\n    assert D.dot.simulate[0].ensemble.barostat.tau == str(2.0)\n    assert D.dot.simulate[0].eneseq.interval == str(0.3)\n    assert D.dot.simulate[0].trajectory.center == 'solute' # &lt;---\n\n    assert len(D.dot.simulate[1].meta.cv) == 1\n    assert len(D.dot.simulate[1].meta.cv[0].atom) == 4\n    assert D.dot.simulate[1].meta.height == str(0.03)\n    assert D.dot.simulate[-1].meta.cv[0].wall == str(0)\n\n    D.dot.simulate[0].ensemble.barostat.tau = 2.1\n    assert D.dot.simulate[0].ensemble.barostat.tau == 2.1\n\n    D.dot.simulate[1].meta.height = 0.06\n    assert D.dot.simulate[1].meta.height == 0.06\n\n    D.dot.simulate[-1].meta.cv[0].wall = 50.0\n    assert D.dot.simulate[-1].meta.cv[0].wall == 50.0\n\n\ndef test_Multisim_expression_5():\n    D= Multisim(template=\"desmond-md.msj\")\n    D.write()\n</code></pre>"},{"location":"index.html#caution","title":"Caution","text":"<p>Some keywords in the <code>.msj</code> or <code>.cfg</code> files may conflict with the reserved python syntax. In the below example, accessing the <code>class</code> variable by directly using the <code>.dot</code> expression such as <code>D.dot.ensemble.class = 'NVT'</code> would raise a <code>SyntaxError</code> because <code>class</code> is a reserved word in Python. However, you can avoid the error by using a dictionary type access such as <code>D.dot.ensemble['class'] = 'NVT'</code>.</p> <pre><code>    ensemble = {\n        brownie = {\n            delta_max = 0.1\n        }\n        class = NVT\n        method = Brownie\n        thermostat = {\n            tau = 1.0\n        }\n    }\n</code></pre>"},{"location":"index.html#use-of-multisim-class","title":"Use of Multisim Class","text":"<p>The <code>desmondtools.Multisim</code> class facilitates reading and modifying Schrodinger Desmond <code>.msj</code> and <code>.cfg</code> files, which are typically generated by Schrodinger Maestro GUI task panels. By using a simple Python script with <code>desmondtools</code>, you can efficiently prepare and set up multiple MD simulations without repeatedly launching Maestro or manually editing files. The example below demonstrates how to modify or create the contents of <code>.msj</code> and <code>.cfg</code> files using the <code>.dot</code> attribute of a <code>Multisim</code> instance.</p> <pre><code>from desmondtools import Multisim\n\n# read template .msj and .cfg\nmd_msj = Multisim(template=\"desmond-md.msj\")\nmd_cfg = Multisim(template=\"desmond-md.cfg\")\n\nwith open(msj_file,\"w\") as msj:\n    # modify desmond msj template\n    md_msj.dot.simulate[-1].cfg_file = cfg_file_basename\n\n    # Setting up restraints using the restraints keyword:\n    # https://www.schrodinger.com/kb/332119\n    if args.posres_force &gt; 0.0:\n        # print the restraints in the multisim log file\n        md_msj.dot.simulate[-1].print_restraint = 'true'\n\n        # add the new terms defined in \"restraints.new\" to existing restraints.\n        # The default is restraints.existing = ignore which will \n        # delete existing terms before adding any new ones.\n        # md_msj.dot.simulate[-1].restraints.existing = 'retain'\n\n        md_msj.dot.simulate[-1].restraints.new = [\n            {\n                'name'              : 'posre_harm',\n                'atoms'             : [ f'\"{args.posres}\"' ],\n                'force_constants'   : [ args.posres_force, ] * 3,\n            }\n            ]\n        # force constants in the x, y, and z direction\n\n    # writing modified msj\n    md_msj.write(msj)\n\nwith open(cfg_file,\"w\") as cfg:\n    # read and modify desmond cfg template\n    md_cfg.dot.randomize_velocity.seed = random.randint(1000, 9999)\n    md_cfg.dot.time = total_simulation_time\n    md_cfg.dot.temperature = t_schedule\n    md_cfg.dot.trajectory.interval = args.interval\n    # wring modified cfg\n    md_cfg.write(cfg)\n</code></pre> <p>Below are examples of <code>.msj</code> and <code>.cfg</code> files:</p> <pre><code># .msj file example (part)\n\ntask {\n   task = \"desmond:auto\"\n   set_family = {\n      desmond = {\n         checkpt.write_last_step = no\n      }\n   }\n}\n\nsimulate {\n   title       = \"Brownian Dynamics NVT, T = 10 K, small timesteps, ...\"\n   annealing   = off\n   time        = 100\n   timestep    = [0.001 0.001 0.003 ]\n   temperature = 10.0\n   ensemble = {\n      class = \"NVT\"\n      method = \"Brownie\"\n      brownie = {\n         delta_max = 0.1\n      }\n   }\n   restrain = {\n      atom = \"solute_heavy_atom\"\n      force_constant = 50.0\n   }\n}\n\nsimulate {\n   effect_if   = [[\"==\" \"-gpu\" \"@*.*.jlaunch_opt[-1]\"] 'ensemble.method = Langevin']\n   title       = \"NVT, T = 10 K, small timesteps, ...\"\n   annealing   = off\n   time        = 12\n   timestep    = [0.001 0.001 0.003]\n   temperature = 10.0\n   restrain    = { atom = solute_heavy_atom force_constant = 50.0 }\n   ensemble    = {\n      class  = NVT\n      method = Berendsen\n      thermostat.tau = 0.1\n   }\n\n   randomize_velocity.interval = 1.0\n   eneseq.interval             = 0.3\n   trajectory.center           = []\n}\n</code></pre> <pre><code># .cfg file example (part)\n\nrandomize_velocity = {\n   first = 0.0\n   interval = inf\n   seed = 2967\n   temperature = \"@*.temperature\"\n}\nrestrain = none\nsimbox = {\n   first = 0.0\n   interval = 1.2\n   name = \"$JOBNAME$[_replica$REPLICA$]_simbox.dat\"\n}\nsurface_tension = 0.0\ntaper = false\ntemperature = [\n   [300.0 0 ]\n]\ntime = 100000.0\ntimestep = [0.002 0.002 0.006 ]\n</code></pre>"},{"location":"index.html#event-and-interaction-classes","title":"Event and Interaction Classes","text":"<p>Schrodinger event analysis format or <code>.eaf</code> files use the same syntax as the <code>.cfg</code> or <code>.msj</code> files. So, the <code>desmondtools.Multisim</code> class is reused in the <code>desmondtools.Event</code> and <code>desmondtools.Interaction</code> classes to process Schrodinger provided trajectory analysis output <code>...-out.eaf</code> files. For example, below codes from <code>desmondtools.Interaction</code> class shows how the class uses the <code>.dot</code> attributes to process <code>.eaf</code> output files.</p> <pre><code>for section in self.dot.Keywords:\n    try:\n        assert section.ProtLigInter.HBondResult\n        self.num_frames = len(section.ProtLigInter.HBondResult)\n        for frame in section.ProtLigInter.HBondResult:\n            # [[3 \"_:ARG_143:HH22\" d-s \"L-FRAG_0:N6\" ]]\n            for (frameno, prot, hbond_type, lig) in frame:\n                prot = prot.strip('\\\"')\n                (_, resid, atom) = prot.split(\":\")\n                (resName, resSeq) = resid.split(\"_\")\n                resSeq = int(resSeq)\n                if resSeq in self.HBond:\n                    self.HBond[resSeq]['count'] += 1\n                else:\n                    self.HBond[resSeq] = {'resName': resName, 'count':1 }\n        for resSeq in sorted(self.HBond):\n            fraction = float(self.HBond[resSeq]['count'])/self.num_frames\n            if verbose:\n                print(f\"HBond {self.HBond[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n    except:\n        pass\n</code></pre>"},{"location":"index.html#command-line-interface","title":"Command-Line Interface","text":"<p>Command-Line Interfaces (CLI) are built on the <code>Multisim</code> class. Some CLIs require Schrodinger Python API.</p> Command-line interface Description batch-desmond-cif Convert .mae/.maegz to .cif batch-desmond-mdinfo Check running MD simulations batch-desmond-maeinfo Show info of .mae/.maegz file(s) batch-desmond-cmsinfo Show info of .cms file(s) batch-desmond-setup Batch Prepare MD systems batch-desmond-min Batch Setup energy minimizations batch-desmond-md Batch Setup MD simulations batch-desmond-metad Batch Setup metadynamics batch-desmond-report Batch Generate reports batch-desmond-pli Batch Analyze protein-ligand interactions batch-desmond-distance Batch Analyze distance batch-desmond-dihedral Batch Analyze dihedral angles batch-desmond-ligrmsd Batch Analyze ligand rmsd batch-desmond-rg Batch Analyze radius of gyration batch-desmond-rmsx Batch Analyze RMSD and ligand RMSF batch-desmond-mmgbsa Batch Analyze trajectory MMGBSA <p>For more helps, <code>$ command --help</code>.</p>"},{"location":"index.html#metadynamics","title":"Metadynamics","text":""},{"location":"index.html#types-of-collective-variables","title":"Types of Collective Variables","text":"type Description Default Width Wall Floor Atom sites dist Distance 0.05 \u00c5 yes yes 2 angle Angle 2.5\u00b0 yes yes 3 dihedral Dihedral 5.0\u00b0 no no 4 rgyr Radius of gyration 0.1 \u00c5 no no 1 rgyr_mass Mass-weighted radius of gyration 0.1 \u00c5 no no 1 rmsd RMSD from aligned starting structure 0.1 \u00c5 no no 1 rmsd_symm Symmetry aware RMSD 0.1 \u00c5 no no 1 zdist Distance along the z axis 0.05 \u00c5 yes yes 1 zdist0 Absolute distance along the z axis 0.1 \u00c5 yes yes 1 whim1 WHIM1 - first principal moment [35] 0.5 \u00c52 no no 1 whim2 WHIM2 - second principal moment [35] 0.25 \u00c52 no no 1"},{"location":"index.html#examples-of-collective-variables","title":"Examples of Collective Variables","text":"<pre><code>distance:\n    cv = [\n        {atom = [\"res. UNK\" \"res. 849\" ]\n        type = dist\n        wall = 40\n        floor = 10\n        width = 0.05\n        }\n    ]\n\ndihedral:\n    cv = [\n        {atom = [404 406 407 415 ]\n        type = dihedral\n        width = 5.0\n        }\n        {atom = [406 407 415 417 ]\n        type = dihedral\n        width = 5.0\n        }\n    ]\n\nzdist(membrane):\n    cv = [\n        {atom = [\"res. UNK\"]\n        type = zdist\n        width = 0.05\n        wall = 20\n        floor = 5\n        }\n        ]\n\nrmsd:\n    cv = [\n        {atom = [\"res. UNK\" \"res. 849\" ]\n        type = rmsd\n        width = 0.1\n        }\n    ]\n</code></pre>"},{"location":"index.html#well-tempered-metadynamics","title":"Well-Tempered Metadynamics","text":"<p>In well-tempered metadynamics, the height of the deployed Gaussians are rescaled (decreased) during simulation time by: omega_0 * exp(-V/(kB * \u0394T)) Where omega_0 is the initial hill height, V is the bias potential and the denominator in the exponential, kB * \u0394T, is the bias factor (kTemp). During well-tempered metadynamics, the dynamics of the system are effectively accelerated  (without heating up the system) up to T + \u0394T, where T is the chosen MD simulation temperature.  The choice of the bias factor value is guided by the highest barrier in the simulation system  which the well-tempered metadynamics run should overcome. Here are some suggestions,  assuming that the initial hill height \u03c90 (height parameter in the Metadynamics panel) has been set to 0.3 kcal/mol:</p> Max. barrier height (kcal/mol) kTemp (kcal/mol) 3 1.7 6 3.4 10 5.6 15 8.4 20 11.2"},{"location":"index.html#extending-simulations","title":"Extending Simulations","text":"<p>See https://www.schrodinger.com/kb/788642 for extending metadynamics simulation.</p>"},{"location":"index.html#python-classes","title":"Python Classes","text":""},{"location":"index.html#desmondtools.Multisim","title":"<code>desmondtools.Multisim</code>","text":"<p>Parsing Desmond multisim .cfg and .msj expressions</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>class Multisim:\n    \"\"\"Parsing Desmond multisim .cfg and .msj expressions\"\"\"\n    # variable, value, array, expr\n    # pyparsing module\u2019s default behavior is to ignore whitespace.\n    # +: AND, |: MatchFirst, left-to-right, ^: Or(longest match)\n    # Group: --&gt; list\n    # Dict: --&gt; dict\n    # Forward: --&gt; recursive\n\n    EQ = pp.Suppress('=')\n    LBRACKET, RBRACKET, LBRACE, RBRACE = map(pp.Literal, \"[]{}\")\n    variable = (pp.Word(pp.alphanums + \"._/?-@\") + \n                pp.Opt(\".\" + pp.Word(pp.alphanums))).set_parse_action(''.join)\n    _string1 = pp.Word(pp.alphanums + \"._/?-@*\")\n    _string2 = pp.quoted_string()\n    _number  = ppc.number()\n    value   = (_string1 | _string2 | _number)\n    array   = pp.Forward()\n    array   &lt;&lt;= pp.Group(LBRACKET + (pp.ZeroOrMore(value | array)) + RBRACKET)\n    expr    = pp.Forward()\n    _expr_0  = (variable + EQ + value)\n    _expr_1  = (variable + EQ + array)\n    _expr_2  = (variable + EQ + pp.Group(\n        LBRACE + pp.ZeroOrMore(expr) + RBRACE ))\n    _expr_3  = (variable + EQ + pp.Group(\n        LBRACKET + pp.ZeroOrMore(pp.Group(LBRACE + expr + RBRACE)) + RBRACKET))\n    _expr_4  = pp.Group(variable + pp.Group(\n        LBRACE + pp.ZeroOrMore( expr ) + RBRACE))\n    expr    &lt;&lt;= pp.OneOrMore(pp.Dict(pp.Group(\n        _expr_0 | _expr_1 | _expr_2 | _expr_3 | _expr_4)))\n    expr.ignore(\"#\" + pp.restOfLine)\n\n\n    def __init__(self, **kwargs):\n        self.template_path = None\n        self.ParseResults = None\n        self.dict = {}\n        self.dot = DotMap()\n        self.output = sys.stdout # do not attempt to close\n        self.indent = 4\n\n        if 'template' in kwargs:\n            template = kwargs['template']\n            template_path = pathlib.Path(template)\n            if template_path.is_file():\n                self.template_path = template_path\n            else:\n                template_path = importlib.resources.files('desmondtools')\n                self.template_path = template_path / template\n            if self.template_path is None:\n                raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), template)\n\n            self.ParseResults = Multisim.expr.parse_file(self.template_path)\n            self.decode()\n\n        elif 'string' in kwargs:\n            string = kwargs['string']\n            try:\n                self.ParseResults = Multisim.expr.parse_string(string)\n                self.decode()\n            except:\n                raise RuntimeError(\"Multisim: cannot parse the input string.\")\n        else:\n            raise RuntimeError(\"Multisim: template filename or string is required.\")\n\n\n\n    @staticmethod\n    def unfold_dict_key(d) -&gt; None:\n        \"\"\"Unfold '.' in the keys of a dictionary\n\n        Args:\n            d (dict): dictionary (to be modified)\n        \"\"\"\n        ks = [ k for k in d ]\n        for k in ks:\n            v = d[k]\n            if '.' in k:\n                # d[k] = v --&gt; d[kk[0]] = { kk[1] : v }\n                _u = None\n                _k = k.split('.')[0]\n                for kk in k.split('.')[-1:0:-1]:\n                    if _u is None:\n                        _u = {kk : v }\n                    else:\n                        _u = {kk : _u}\n                d[_k] = _u\n                del d[k]\n            else:\n                pass\n            if isinstance(v, dict):\n                Multisim.unfold_dict_key(v)\n\n\n    @staticmethod\n    def traverse_dict(d) -&gt; None:\n        \"\"\"Recursively traverse a nested dictionary/list\n\n        Args:\n            d (dict): dictionary (to be modified)\n        \"\"\"\n        if isinstance(d, dict):\n            for k,v in d.items():\n                if isinstance(v, dict):\n                    Multisim.traverse_dict(v)            \n                elif isinstance(v, list):\n                    if v == ['{','}']:\n                        d[k] = {}\n                    elif v == ['[',']']:\n                        d[k] = []\n                    elif v[0] == '[' and v[-1] == ']':\n                        d[k] = v[1:-1]\n                        Multisim.traverse_dict(d[k])\n                    elif v[0] == '{' and v[-1] == '}':\n                        d[k] = dict(v[1:-1])\n                        Multisim.traverse_dict(d[k])\n        elif isinstance(d, list):\n            for k,v in enumerate(d):\n                if isinstance(v, dict):\n                    Multisim.traverse_dict(v)\n                elif isinstance(v, list):\n                    if v == ['{','}']:\n                        d[k] = {}\n                    elif v == ['[',']']:\n                        d[k] = []\n                    elif v[0] == '[' and v[-1] == ']':\n                        d[k] = v[1:-1]\n                        Multisim.traverse_dict(d[k])\n                    elif v[0] == '{' and v[-1] == '}':\n                        d[k] = dict(v[1:-1])\n                        Multisim.traverse_dict(d[k])\n\n\n    def decode(self) -&gt; None:\n        \"\"\"decode the parsed results into a dictionary and its dotmap\"\"\"\n        # create .dict\n        if isinstance(self.ParseResults.as_list()[0][0], str): # key\n            self.dict = self.ParseResults.as_dict()\n            Multisim.traverse_dict(self.dict)\n            # handle the case where key has '.'\n            Multisim.unfold_dict_key(self.dict)\n\n        elif isinstance(self.ParseResults.as_list()[0][0], list):\n            self.dict = [] # now self.dict is a list of dictionary\n            for section in self.ParseResults:\n                dict_ = dict(section.as_list())\n                Multisim.traverse_dict(dict_)\n                # handle the case where key has '.'\n                Multisim.unfold_dict_key(dict_)\n                self.dict.append(dict_)\n\n        # create .dot\n        if isinstance(self.dict, list):\n            self.dot = {}\n            for d in self.dict:\n                for k,v in d.items():\n                    if k in self.dot:\n                        if isinstance(self.dot[k], list):\n                            self.dot[k].append(v)\n                        else:\n                            self.dot[k] = [self.dot[k], v]\n                    else:\n                        self.dot[k] = v\n            self.dot = DotMap(self.dot)\n        else:\n            self.dot = DotMap(self.dict)\n\n\n\n    def write(self, output=None):\n        \"\"\"Writes DOT object\"\"\"\n        if isinstance(output, io.IOBase):\n            self.output = output\n        elif isinstance(output, str):\n            self.output = open(output, \"w\")\n\n        if isinstance(self.dict, list):\n            blocks = []\n            for k, v in self.dot.items():\n                if isinstance(v, list):\n                    for vv in v:\n                        blocks.append({k:vv})\n                else:\n                    blocks.append({k:v})\n            for block in blocks:\n                self._write_dict(block, block=True)\n                self.output.write(\"\\n\")\n        else:\n            self._write_dict(self.dot)\n\n\n    def _write_dict(self, d, block=False, depth=0):\n        \"\"\"subroutine of .write() method\"\"\"\n        spc = ' ' * self.indent * depth\n        if isinstance(d, dict) or isinstance(d, DotMap):\n            for k, v in d.items():\n                k = str(k)\n                if v:\n                    if isinstance(v, dict) or isinstance(v, DotMap):\n                        if depth == 0 and block:\n                            self.output.write(spc + k + \" {\\n\")\n                        else:\n                            self.output.write(spc + k + \" = {\\n\")\n                        self._write_dict(v, depth=depth+1)\n                        self.output.write(spc + \"}\\n\")\n                    elif isinstance(v, list):\n                        self.output.write(spc + k + \" = [\")\n                        for vv in v:\n                            if isinstance(vv, dict) or isinstance(vv, DotMap): \n                                self.output.write(\"{\\n\")\n                            elif isinstance(vv, list):\n                                self.output.write(\"[\")\n                            self._write_dict(vv, depth=depth+1)\n                            if isinstance(vv, dict) or isinstance(vv, DotMap):\n                                self.output.write(spc + \"}\")\n                            elif isinstance(vv, list):\n                                self.output.write(\"]\")                \n                        self.output.write(\"]\\n\")\n                    else:\n                        self.output.write(spc + k + \" = \" + str(v) +\"\\n\")\n                else:\n                    if isinstance(v, list) and (not bool(v)):\n                        self.output.write(spc + k + \" = []\\n\")\n                    elif (isinstance(v, dict) or isinstance(v, DotMap))and (not bool(v)):\n                        self.output.write(spc + k + \" = {\\n}\\n\")\n                    else:\n                        self.output.write(spc + k + \" =   \\n\")\n        elif isinstance(d, list):\n            for v in d:\n                self._write_dict(v, depth=depth+1)\n        else:\n            self.output.write(\" \" + str(d) + \" \")\n\n\n    def to_dot(self) -&gt; DotMap:\n        \"\"\"Returns parsed results as a DotMap object\n\n        Returns:\n            DotMap : DotMap object\n        \"\"\"\n        return self.dot\n\n\n    def to_list(self) -&gt; list:\n        \"\"\"Returns parsed results as a list\n\n        Returns:\n            list : list\n        \"\"\"\n        return self.ParseResults.as_list()\n\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Returns parsed results as a dictionary\n\n        Returns:\n            dict : dictionary\n        \"\"\"\n        return self.dict\n</code></pre>"},{"location":"index.html#desmondtools.Multisim-attributes","title":"Attributes","text":""},{"location":"index.html#desmondtools.Multisim.EQ","title":"<code>EQ = pp.Suppress('=')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.ParseResults","title":"<code>ParseResults = Multisim.expr.parse_string(string)</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_0","title":"<code>_expr_0 = variable + EQ + value</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_1","title":"<code>_expr_1 = variable + EQ + array</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_2","title":"<code>_expr_2 = variable + EQ + pp.Group(LBRACE + pp.ZeroOrMore(expr) + RBRACE)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_3","title":"<code>_expr_3 = variable + EQ + pp.Group(LBRACKET + pp.ZeroOrMore(pp.Group(LBRACE + expr + RBRACE)) + RBRACKET)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_4","title":"<code>_expr_4 = pp.Group(variable + pp.Group(LBRACE + pp.ZeroOrMore(expr) + RBRACE))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._number","title":"<code>_number = ppc.number()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._string1","title":"<code>_string1 = pp.Word(pp.alphanums + '._/?-@*')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._string2","title":"<code>_string2 = pp.quoted_string()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.array","title":"<code>array = pp.Forward()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.dict","title":"<code>dict = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.dot","title":"<code>dot = DotMap()</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.expr","title":"<code>expr = pp.Forward()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.indent","title":"<code>indent = 4</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.output","title":"<code>output = sys.stdout</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.template_path","title":"<code>template_path = None</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.value","title":"<code>value = _string1 | _string2 | _number</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.variable","title":"<code>variable = pp.Word(pp.alphanums + '._/?-@') + pp.Opt('.' + pp.Word(pp.alphanums)).set_parse_action(''.join)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim-functions","title":"Functions","text":""},{"location":"index.html#desmondtools.Multisim.__init__","title":"<code>__init__(**kwargs)</code>","text":"Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def __init__(self, **kwargs):\n    self.template_path = None\n    self.ParseResults = None\n    self.dict = {}\n    self.dot = DotMap()\n    self.output = sys.stdout # do not attempt to close\n    self.indent = 4\n\n    if 'template' in kwargs:\n        template = kwargs['template']\n        template_path = pathlib.Path(template)\n        if template_path.is_file():\n            self.template_path = template_path\n        else:\n            template_path = importlib.resources.files('desmondtools')\n            self.template_path = template_path / template\n        if self.template_path is None:\n            raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), template)\n\n        self.ParseResults = Multisim.expr.parse_file(self.template_path)\n        self.decode()\n\n    elif 'string' in kwargs:\n        string = kwargs['string']\n        try:\n            self.ParseResults = Multisim.expr.parse_string(string)\n            self.decode()\n        except:\n            raise RuntimeError(\"Multisim: cannot parse the input string.\")\n    else:\n        raise RuntimeError(\"Multisim: template filename or string is required.\")\n</code></pre>"},{"location":"index.html#desmondtools.Multisim._write_dict","title":"<code>_write_dict(d, block=False, depth=0)</code>","text":"<p>subroutine of .write() method</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def _write_dict(self, d, block=False, depth=0):\n    \"\"\"subroutine of .write() method\"\"\"\n    spc = ' ' * self.indent * depth\n    if isinstance(d, dict) or isinstance(d, DotMap):\n        for k, v in d.items():\n            k = str(k)\n            if v:\n                if isinstance(v, dict) or isinstance(v, DotMap):\n                    if depth == 0 and block:\n                        self.output.write(spc + k + \" {\\n\")\n                    else:\n                        self.output.write(spc + k + \" = {\\n\")\n                    self._write_dict(v, depth=depth+1)\n                    self.output.write(spc + \"}\\n\")\n                elif isinstance(v, list):\n                    self.output.write(spc + k + \" = [\")\n                    for vv in v:\n                        if isinstance(vv, dict) or isinstance(vv, DotMap): \n                            self.output.write(\"{\\n\")\n                        elif isinstance(vv, list):\n                            self.output.write(\"[\")\n                        self._write_dict(vv, depth=depth+1)\n                        if isinstance(vv, dict) or isinstance(vv, DotMap):\n                            self.output.write(spc + \"}\")\n                        elif isinstance(vv, list):\n                            self.output.write(\"]\")                \n                    self.output.write(\"]\\n\")\n                else:\n                    self.output.write(spc + k + \" = \" + str(v) +\"\\n\")\n            else:\n                if isinstance(v, list) and (not bool(v)):\n                    self.output.write(spc + k + \" = []\\n\")\n                elif (isinstance(v, dict) or isinstance(v, DotMap))and (not bool(v)):\n                    self.output.write(spc + k + \" = {\\n}\\n\")\n                else:\n                    self.output.write(spc + k + \" =   \\n\")\n    elif isinstance(d, list):\n        for v in d:\n            self._write_dict(v, depth=depth+1)\n    else:\n        self.output.write(\" \" + str(d) + \" \")\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.decode","title":"<code>decode()</code>","text":"<p>decode the parsed results into a dictionary and its dotmap</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def decode(self) -&gt; None:\n    \"\"\"decode the parsed results into a dictionary and its dotmap\"\"\"\n    # create .dict\n    if isinstance(self.ParseResults.as_list()[0][0], str): # key\n        self.dict = self.ParseResults.as_dict()\n        Multisim.traverse_dict(self.dict)\n        # handle the case where key has '.'\n        Multisim.unfold_dict_key(self.dict)\n\n    elif isinstance(self.ParseResults.as_list()[0][0], list):\n        self.dict = [] # now self.dict is a list of dictionary\n        for section in self.ParseResults:\n            dict_ = dict(section.as_list())\n            Multisim.traverse_dict(dict_)\n            # handle the case where key has '.'\n            Multisim.unfold_dict_key(dict_)\n            self.dict.append(dict_)\n\n    # create .dot\n    if isinstance(self.dict, list):\n        self.dot = {}\n        for d in self.dict:\n            for k,v in d.items():\n                if k in self.dot:\n                    if isinstance(self.dot[k], list):\n                        self.dot[k].append(v)\n                    else:\n                        self.dot[k] = [self.dot[k], v]\n                else:\n                    self.dot[k] = v\n        self.dot = DotMap(self.dot)\n    else:\n        self.dot = DotMap(self.dict)\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns parsed results as a dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Returns parsed results as a dictionary\n\n    Returns:\n        dict : dictionary\n    \"\"\"\n    return self.dict\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_dot","title":"<code>to_dot()</code>","text":"<p>Returns parsed results as a DotMap object</p> <p>Returns:</p> Name Type Description <code>DotMap</code> <code>DotMap</code> <p>DotMap object</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def to_dot(self) -&gt; DotMap:\n    \"\"\"Returns parsed results as a DotMap object\n\n    Returns:\n        DotMap : DotMap object\n    \"\"\"\n    return self.dot\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_list","title":"<code>to_list()</code>","text":"<p>Returns parsed results as a list</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def to_list(self) -&gt; list:\n    \"\"\"Returns parsed results as a list\n\n    Returns:\n        list : list\n    \"\"\"\n    return self.ParseResults.as_list()\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.traverse_dict","title":"<code>traverse_dict(d)</code>  <code>staticmethod</code>","text":"<p>Recursively traverse a nested dictionary/list</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>dictionary (to be modified)</p> required Source code in <code>src/desmondtools/multisim.py</code> <pre><code>@staticmethod\ndef traverse_dict(d) -&gt; None:\n    \"\"\"Recursively traverse a nested dictionary/list\n\n    Args:\n        d (dict): dictionary (to be modified)\n    \"\"\"\n    if isinstance(d, dict):\n        for k,v in d.items():\n            if isinstance(v, dict):\n                Multisim.traverse_dict(v)            \n            elif isinstance(v, list):\n                if v == ['{','}']:\n                    d[k] = {}\n                elif v == ['[',']']:\n                    d[k] = []\n                elif v[0] == '[' and v[-1] == ']':\n                    d[k] = v[1:-1]\n                    Multisim.traverse_dict(d[k])\n                elif v[0] == '{' and v[-1] == '}':\n                    d[k] = dict(v[1:-1])\n                    Multisim.traverse_dict(d[k])\n    elif isinstance(d, list):\n        for k,v in enumerate(d):\n            if isinstance(v, dict):\n                Multisim.traverse_dict(v)\n            elif isinstance(v, list):\n                if v == ['{','}']:\n                    d[k] = {}\n                elif v == ['[',']']:\n                    d[k] = []\n                elif v[0] == '[' and v[-1] == ']':\n                    d[k] = v[1:-1]\n                    Multisim.traverse_dict(d[k])\n                elif v[0] == '{' and v[-1] == '}':\n                    d[k] = dict(v[1:-1])\n                    Multisim.traverse_dict(d[k])\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.traverse_dict(d)","title":"<code>d</code>","text":""},{"location":"index.html#desmondtools.Multisim.unfold_dict_key","title":"<code>unfold_dict_key(d)</code>  <code>staticmethod</code>","text":"<p>Unfold '.' in the keys of a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <p>dictionary (to be modified)</p> required Source code in <code>src/desmondtools/multisim.py</code> <pre><code>@staticmethod\ndef unfold_dict_key(d) -&gt; None:\n    \"\"\"Unfold '.' in the keys of a dictionary\n\n    Args:\n        d (dict): dictionary (to be modified)\n    \"\"\"\n    ks = [ k for k in d ]\n    for k in ks:\n        v = d[k]\n        if '.' in k:\n            # d[k] = v --&gt; d[kk[0]] = { kk[1] : v }\n            _u = None\n            _k = k.split('.')[0]\n            for kk in k.split('.')[-1:0:-1]:\n                if _u is None:\n                    _u = {kk : v }\n                else:\n                    _u = {kk : _u}\n            d[_k] = _u\n            del d[k]\n        else:\n            pass\n        if isinstance(v, dict):\n            Multisim.unfold_dict_key(v)\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.unfold_dict_key(d)","title":"<code>d</code>","text":""},{"location":"index.html#desmondtools.Multisim.write","title":"<code>write(output=None)</code>","text":"<p>Writes DOT object</p> Source code in <code>src/desmondtools/multisim.py</code> <pre><code>def write(self, output=None):\n    \"\"\"Writes DOT object\"\"\"\n    if isinstance(output, io.IOBase):\n        self.output = output\n    elif isinstance(output, str):\n        self.output = open(output, \"w\")\n\n    if isinstance(self.dict, list):\n        blocks = []\n        for k, v in self.dot.items():\n            if isinstance(v, list):\n                for vv in v:\n                    blocks.append({k:vv})\n            else:\n                blocks.append({k:v})\n        for block in blocks:\n            self._write_dict(block, block=True)\n            self.output.write(\"\\n\")\n    else:\n        self._write_dict(self.dot)\n</code></pre>"},{"location":"index.html#desmondtools.Event","title":"<code>desmondtools.Event</code>","text":"Source code in <code>src/desmondtools/event.py</code> <pre><code>class Event:\n    def __init__(self, filename:Path | str):\n        if isinstance(filename, Path):\n            result = Multisim.expr.parse_file(filename.as_posix())\n        else:\n            result = Multisim.expr.parse_file(filename)\n        d = result.as_dict()\n        Multisim.traverse_dict(d)\n        self.dot = DotMap(d)\n</code></pre>"},{"location":"index.html#desmondtools.Event-attributes","title":"Attributes","text":""},{"location":"index.html#desmondtools.Event.dot","title":"<code>dot = DotMap(d)</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Event-functions","title":"Functions","text":""},{"location":"index.html#desmondtools.Event.__init__","title":"<code>__init__(filename)</code>","text":"Source code in <code>src/desmondtools/event.py</code> <pre><code>def __init__(self, filename:Path | str):\n    if isinstance(filename, Path):\n        result = Multisim.expr.parse_file(filename.as_posix())\n    else:\n        result = Multisim.expr.parse_file(filename)\n    d = result.as_dict()\n    Multisim.traverse_dict(d)\n    self.dot = DotMap(d)\n</code></pre>"},{"location":"index.html#desmondtools.Interaction","title":"<code>desmondtools.Interaction</code>","text":"<p>               Bases: <code>Event</code></p> Source code in <code>src/desmondtools/event.py</code> <pre><code>class Interaction(Event):\n    def __init__(self, filename:Path | str, verbose:bool=False):\n        super().__init__(filename)\n\n        self.num_frames = 0\n        self.HBond = {}\n        self.Hydrophobic = {}\n        self.WaterBridge = {}\n        self.Polar = {}\n        self.HalogenBond = {}\n        self.LigWat = {}\n        self.Metal = {}\n        self.PiCat = {}\n        self.PiPi = {}\n\n        for section in self.dot.Keywords:\n            try:\n                assert section.ProtLigInter.HBondResult\n                self.num_frames = len(section.ProtLigInter.HBondResult)\n                for frame in section.ProtLigInter.HBondResult:\n                    # [[3 \"_:ARG_143:HH22\" d-s \"L-FRAG_0:N6\" ]]\n                    for (frameno, prot, hbond_type, lig) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid, atom) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.HBond:\n                            self.HBond[resSeq]['count'] += 1\n                        else:\n                            self.HBond[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.HBond):\n                    fraction = float(self.HBond[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"HBond {self.HBond[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n\n            try:\n                assert section.ProtLigInter.HydrophobicResult\n                self.num_frames = len(section.ProtLigInter.HydrophobicResult)\n                for frame in section.ProtLigInter.HydrophobicResult:\n                    # [[0 \"_:PHE_223\" L-FRAG_0 ] [0 \"_:ALA_241\" L-FRAG_0 ]]\n                    for (frameno, prot, lig) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.Hydrophobic:\n                            self.Hydrophobic[resSeq]['count'] += 1\n                        else:\n                            self.Hydrophobic[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.Hydrophobic):\n                    fraction = float(self.Hydrophobic[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"Hydrophobic {self.Hydrophobic[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n\n            try:\n                assert section.ProtLigInter.PolarResult\n                self.num_frames = len(section.ProtLigInter.PolarResult)\n                for frame in section.ProtLigInter.PolarResult:\n                    # [[1 \"_:GLU_216:OE2\" b \"L-FRAG_1:N3\" 4.45 ]]\n                    for (frameno, prot, _, lig, _) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid, atom) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.Polar:\n                            self.Polar[resSeq]['count'] += 1\n                        else:\n                            self.Polar[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.Polar):\n                    fraction = float(self.Polar[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"Polar {self.Polar[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n\n            try:\n                assert section.ProtLigInter.WaterBridgeResult\n                self.num_frames = len(section.ProtLigInter.WaterBridgeResult)\n                for frame in section.ProtLigInter.WaterBridgeResult:\n                    # [[3 \"_:GLU_216:OE2\" a \"L-FRAG_0:N2\" a 2431 ]]\n                    for (frameno, prot, _, lig, _, _) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid, atom) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.WaterBridge:\n                            self.WaterBridge[resSeq]['count'] += 1\n                        else:\n                            self.WaterBridge[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.WaterBridge):\n                    fraction = float(self.WaterBridge[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"WaterBridge {self.WaterBridge[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n</code></pre>"},{"location":"index.html#desmondtools.Interaction-attributes","title":"Attributes","text":""},{"location":"index.html#desmondtools.Interaction.HBond","title":"<code>HBond = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.HalogenBond","title":"<code>HalogenBond = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.Hydrophobic","title":"<code>Hydrophobic = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.LigWat","title":"<code>LigWat = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.Metal","title":"<code>Metal = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.PiCat","title":"<code>PiCat = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.PiPi","title":"<code>PiPi = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.Polar","title":"<code>Polar = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.WaterBridge","title":"<code>WaterBridge = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.num_frames","title":"<code>num_frames = len(section.ProtLigInter.WaterBridgeResult)</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction-functions","title":"Functions","text":""},{"location":"index.html#desmondtools.Interaction.__init__","title":"<code>__init__(filename, verbose=False)</code>","text":"Source code in <code>src/desmondtools/event.py</code> <pre><code>def __init__(self, filename:Path | str, verbose:bool=False):\n    super().__init__(filename)\n\n    self.num_frames = 0\n    self.HBond = {}\n    self.Hydrophobic = {}\n    self.WaterBridge = {}\n    self.Polar = {}\n    self.HalogenBond = {}\n    self.LigWat = {}\n    self.Metal = {}\n    self.PiCat = {}\n    self.PiPi = {}\n\n    for section in self.dot.Keywords:\n        try:\n            assert section.ProtLigInter.HBondResult\n            self.num_frames = len(section.ProtLigInter.HBondResult)\n            for frame in section.ProtLigInter.HBondResult:\n                # [[3 \"_:ARG_143:HH22\" d-s \"L-FRAG_0:N6\" ]]\n                for (frameno, prot, hbond_type, lig) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.HBond:\n                        self.HBond[resSeq]['count'] += 1\n                    else:\n                        self.HBond[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.HBond):\n                fraction = float(self.HBond[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"HBond {self.HBond[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.HydrophobicResult\n            self.num_frames = len(section.ProtLigInter.HydrophobicResult)\n            for frame in section.ProtLigInter.HydrophobicResult:\n                # [[0 \"_:PHE_223\" L-FRAG_0 ] [0 \"_:ALA_241\" L-FRAG_0 ]]\n                for (frameno, prot, lig) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.Hydrophobic:\n                        self.Hydrophobic[resSeq]['count'] += 1\n                    else:\n                        self.Hydrophobic[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.Hydrophobic):\n                fraction = float(self.Hydrophobic[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"Hydrophobic {self.Hydrophobic[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.PolarResult\n            self.num_frames = len(section.ProtLigInter.PolarResult)\n            for frame in section.ProtLigInter.PolarResult:\n                # [[1 \"_:GLU_216:OE2\" b \"L-FRAG_1:N3\" 4.45 ]]\n                for (frameno, prot, _, lig, _) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.Polar:\n                        self.Polar[resSeq]['count'] += 1\n                    else:\n                        self.Polar[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.Polar):\n                fraction = float(self.Polar[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"Polar {self.Polar[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.WaterBridgeResult\n            self.num_frames = len(section.ProtLigInter.WaterBridgeResult)\n            for frame in section.ProtLigInter.WaterBridgeResult:\n                # [[3 \"_:GLU_216:OE2\" a \"L-FRAG_0:N2\" a 2431 ]]\n                for (frameno, prot, _, lig, _, _) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.WaterBridge:\n                        self.WaterBridge[resSeq]['count'] += 1\n                    else:\n                        self.WaterBridge[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.WaterBridge):\n                fraction = float(self.WaterBridge[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"WaterBridge {self.WaterBridge[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n</code></pre>"},{"location":"index.html#desmondtools.Maestro","title":"<code>desmondtools.Maestro</code>","text":"<p>Export maestro file</p>"},{"location":"index.html#desmondtools.Maestro--m_atom-block-from-pdb","title":"m_atom block from PDB","text":"<pre><code>1 atom_index\n2 i_m_mmod_type\n3 r_m_x_coord\n4 r_m_y_coord\n5 r_m_z_coord\n6 i_m_residue_number\n7 s_m_mmod_res\n8 s_m_chain_name\n9 i_m_color\n10 r_m_charge1\n11 r_m_charge2\n12 s_m_pdb_residue_name\n13 s_m_pdb_atom_name\n14 i_m_atomic_number\n15 i_m_formal_charge\n16 s_m_color_rgb\n17 s_m_atom_name\n18 i_m_secondary_structure\n19 r_glide_flexr_altx1\n20 r_glide_flexr_altx2\n21 r_glide_flexr_alty1\n22 r_glide_flexr_alty2\n23 r_glide_flexr_altz1\n24 r_glide_flexr_altz2\n25 r_m_pdb_occupancy\n26 r_m_pdb_tfactor\n27 i_glide_flexr_naltpos\n28 i_i_internal_atom_index\n29 i_pdb_PDB_serial\n30 i_pdb_seqres_index\n31 b_glide_flexr_movable\n32 r_m_alt_pdb_occupancy\n33 r_m_alt_pdb_tfactor\n34 r_m_alt_x_coord\n35 r_m_alt_y_coord\n36 r_m_alt_z_coord\n37 r_pdb_alt_occupancy_A\n38 r_pdb_alt_occupancy_B\n39 r_pdb_alt_tfactor_A\n40 r_pdb_alt_tfactor_B\n41 r_pdb_alt_x_coord_A\n42 r_pdb_alt_x_coord_B\n43 r_pdb_alt_y_coord_A\n44 r_pdb_alt_y_coord_B\n45 r_pdb_alt_z_coord_A\n46 r_pdb_alt_z_coord_B\n47 i_m_pdb_convert_problem\n48 i_pdb_alt_PDB_serial\n49 i_pdb_alt_PDB_serial_A\n50 i_pdb_alt_PDB_serial_B\n51 s_pdb_altloc_chars\n</code></pre>"},{"location":"index.html#desmondtools.Maestro--m_atom-block-from-ligand","title":"m_atom block from ligand","text":"<pre><code>i_m_mmod_type\nr_m_x_coord\nr_m_y_coord\nr_m_z_coord\ni_m_residue_number\ni_m_color\nr_m_charge1\nr_m_charge2\ni_m_atomic_number\ni_m_formal_charge\ns_m_color_rgb\ni_sd_original_parity\nb_st_SpecifiedChirality\nr_epik_H2O_pKa\nr_epik_H2O_pKa_uncertainty\n</code></pre>"},{"location":"index.html#desmondtools.Maestro--m_bond-block","title":"m_bond block","text":"<pre><code># First column is bond index #\ni_m_from\ni_m_to\ni_m_order\ni_sd_original_parity\nr_glide_torcontrol_penalty\ns_glide_torcontrol_name\n</code></pre> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>class Maestro:\n    \"\"\"\n    Export maestro file\n\n    m_atom block from PDB\n    =====================\n        1 atom_index\n        2 i_m_mmod_type\n        3 r_m_x_coord\n        4 r_m_y_coord\n        5 r_m_z_coord\n        6 i_m_residue_number\n        7 s_m_mmod_res\n        8 s_m_chain_name\n        9 i_m_color\n        10 r_m_charge1\n        11 r_m_charge2\n        12 s_m_pdb_residue_name\n        13 s_m_pdb_atom_name\n        14 i_m_atomic_number\n        15 i_m_formal_charge\n        16 s_m_color_rgb\n        17 s_m_atom_name\n        18 i_m_secondary_structure\n        19 r_glide_flexr_altx1\n        20 r_glide_flexr_altx2\n        21 r_glide_flexr_alty1\n        22 r_glide_flexr_alty2\n        23 r_glide_flexr_altz1\n        24 r_glide_flexr_altz2\n        25 r_m_pdb_occupancy\n        26 r_m_pdb_tfactor\n        27 i_glide_flexr_naltpos\n        28 i_i_internal_atom_index\n        29 i_pdb_PDB_serial\n        30 i_pdb_seqres_index\n        31 b_glide_flexr_movable\n        32 r_m_alt_pdb_occupancy\n        33 r_m_alt_pdb_tfactor\n        34 r_m_alt_x_coord\n        35 r_m_alt_y_coord\n        36 r_m_alt_z_coord\n        37 r_pdb_alt_occupancy_A\n        38 r_pdb_alt_occupancy_B\n        39 r_pdb_alt_tfactor_A\n        40 r_pdb_alt_tfactor_B\n        41 r_pdb_alt_x_coord_A\n        42 r_pdb_alt_x_coord_B\n        43 r_pdb_alt_y_coord_A\n        44 r_pdb_alt_y_coord_B\n        45 r_pdb_alt_z_coord_A\n        46 r_pdb_alt_z_coord_B\n        47 i_m_pdb_convert_problem\n        48 i_pdb_alt_PDB_serial\n        49 i_pdb_alt_PDB_serial_A\n        50 i_pdb_alt_PDB_serial_B\n        51 s_pdb_altloc_chars\n\n    m_atom block from ligand\n    ========================\n        i_m_mmod_type\n        r_m_x_coord\n        r_m_y_coord\n        r_m_z_coord\n        i_m_residue_number\n        i_m_color\n        r_m_charge1\n        r_m_charge2\n        i_m_atomic_number\n        i_m_formal_charge\n        s_m_color_rgb\n        i_sd_original_parity\n        b_st_SpecifiedChirality\n        r_epik_H2O_pKa\n        r_epik_H2O_pKa_uncertainty\n\n    m_bond block\n    ============\n        # First column is bond index #\n        i_m_from\n        i_m_to\n        i_m_order\n        i_sd_original_parity\n        r_glide_torcontrol_penalty\n        s_glide_torcontrol_name\n    \"\"\"\n\n    # standard DNA/RNA/Protein\n    std_residues = [\n        \"ADE\", \"GUA\", \"CYT\", \"URA\", \"THY\",\n        \"ALA\", \"ARG\", \"ASN\", \"ASP\", \"CYS\", \"GLN\", \"GLU\", \"GLY\", \"HIS\", \"ILE\",\n        \"LEU\", \"LYS\", \"MET\", \"PHE\", \"PRO\", \"SER\", \"THR\", \"TRP\", \"TYR\", \"VAL\",\n    ]\n\n    # conversion to standard residue name\n    std_rename = {\n        \"URI\" : \"URA\",\n        \"CYX\" : \"CYS\", # disulfide-bonded\n        \"CYM\" : \"CYS\", # deprotonated (- charge) and/or bound to metal atoms\n        \"HID\" : \"HIS\", # protonated at delta position\n        \"HIE\" : \"HIS\", # protonated at epsilon\n        \"HIP\" : \"HIS\", # protonated at both delta and epsilon\n    } \n\n    atomic_symbol = {\n         1 : \"H\",   2 : \"He\",  3 : \"Li\",  4 : \"Be\",  5 : \"B\",   6 : \"C\",   7 : \"N\",   8 : \"O\",   9 : \"F\",  10 : \"Ne\",\n        11 : \"Na\", 12 : \"Mg\", 13 : \"Al\", 14 : \"Si\", 15 : \"P\",  16 : \"S\",  17 : \"Cl\", 18 : \"Ar\", 19 : \"K\",  20 : \"Ca\",\n        21 : \"Sc\", 22 : \"Ti\", 23 : \"V\",  24 : \"Cr\", 25 : \"Mn\", 26 : \"Fe\", 27 : \"Co\", 28 : \"Ni\", 29 : \"Cu\", 30 : \"Zn\",\n        31 : \"Ga\", 32 : \"Ge\", 33 : \"As\", 34 : \"Se\", 35 : \"Br\", 36 : \"Kr\", 37 : \"Rb\", 38 : \"Sr\", 39 : \"Y\",  40 : \"Zr\",\n        41 : \"Nb\", 42 : \"Mo\", 43 : \"Tc\", 44 : \"Ru\", 45 : \"Rh\", 46 : \"Pd\", 47 : \"Ag\", 48 : \"Cd\", 49 : \"In\", 50 : \"Sn\",\n        51 : \"Sb\", 52 : \"Te\", 53 : \"I\",  54 : \"Xe\", 55 : \"Cs\", 56 : \"Ba\", 57 : \"La\", 58 : \"Ce\", 59 : \"Pr\", 60 : \"Nd\",\n        61 : \"Pm\", 62 : \"Sm\", 63 : \"Eu\", 64 : \"Gd\", 65 : \"Tb\", 66 : \"Dy\", 67 : \"Ho\", 68 : \"Er\", 69 : \"Tm\", 70 : \"Yb\",\n        71 : \"Lu\", 72 : \"Hf\", 73 : \"Ta\", 74 : \"W\",  75 : \"Re\", 76 : \"Os\", 77 : \"Ir\", 78 : \"Pt\", 79 : \"Au\", 80 : \"Hg\",\n        81 : \"Tl\", 82 : \"Pb\", 83 : \"Bi\", 84 : \"Po\", 85 : \"At\", 86 : \"Rn\", 87 : \"Fr\", 88 : \"Ra\", 89 : \"Ac\", 90 : \"Th\",\n        91 : \"Pa\", 92 : \"U\",  93 : \"Np\", 94 : \"Pu\", 95 : \"Am\", 96 : \"Cm\", 97 : \"Bk\", 98 : \"Cf\", 99 : \"Es\", 100: \"Fm\",\n        101: \"Md\", 102: \"No\", 103: \"Lr\", 104: \"Rf\", 105: \"Db\", 106: \"Sg\", 107: \"Bh\", 108: \"Hs\", 109: \"Mt\", 110: \"Ds\",\n        111: \"Rg\", 112: \"Cn\", 113: \"Nh\", 114: \"Fl\", 115: \"Mc\", 116: \"Lv\", 117: \"Ts\", 118: \"Og\",\n    }\n\n    def __init__(self, filename:str, max_two_entries:bool=True) -&gt; None:\n        \"\"\" initialize \"\"\"\n        if not Path(filename).exists:\n            print(f\"Error file not found: {filename}\")\n            sys.exit(1)\n\n        self.filename = filename\n        self.prefix = None\n        self.contents = None\n\n        if filename.endswith('.maegz'):\n            self.prefix = filename.replace(\".maegz\", \"\")\n            with gzip.open(filename, 'rt') as f:\n                self.contents = f.readlines()\n\n        elif filename.endswith('.mae.gz'):\n            self.prefix = filename.replace(\".mae.gz\", \"\")\n            with gzip.open(filename, \"rt\") as f:\n                self.contents = f.readlines()\n\n        elif filename.endswith('.mae'):\n            self.prefix = filename.replace(\".mae\", \"\")\n            with open(filename, \"rt\") as f:\n                self.contents = f.readlines()\n        else:\n            print(\"Error : .mae, .mae.gz, or .maegz file is expected\")\n            sys.exit(1)\n\n        self.max_two_entries = max_two_entries\n        self.count = re.compile(r'\\[(\\d+)\\]')\n        self.title = \"\"\n        self.serial = 0\n        self.usedId = {}\n        self.mmcif = {\n            \"_entry\": None, \n            \"_chem_comp_bond\": None, \n            \"_atom_site\": None,\n            } # mmcif-like object\n        self.iamap = {}\n\n\n    def append_entry(self, title):\n        \"\"\"Start a new entry.\"\"\"\n        if self.mmcif[\"_entry\"]:\n            if type(self.mmcif[\"_entry\"][\"id\"]) == list:\n                # you got here as the third and later entry\n                if self.max_two_entries:\n                    # write out last two entries\n                    self.write_mmcif()\n                    # return to the state in which only the first entry was defined\n                    self.mmcif = copy.deepcopy(self.mmcif_first)\n                    self.usedId = copy.deepcopy(self.mmcif_first_usedId)\n                    self.serial = self.mmcif_first_serial\n                    # regardless of its appearance, current entry now is regarded as the second entry\n                    self.mmcif[\"_entry\"][\"id\"] = [ self.mmcif[\"_entry\"][\"id\"][0], title ]\n                else:\n                    # otherwise continue to add entry\n                    self.mmcif[\"_entry\"][\"id\"].append(title)\n            else:\n                # you got here as the second entry\n                # save the first entry before adding the second entry\n                self.mmcif_first = copy.deepcopy(self.mmcif)\n                self.mmcif_first_usedId = copy.deepcopy(self.usedId)\n                self.mmcif_first_serial = self.serial\n                # change to a list type\n                self.mmcif[\"_entry\"][\"id\"] = [ self.mmcif[\"_entry\"][\"id\"], title ]\n        else:\n            # regular string type\n            self.mmcif[\"_entry\"] = { \"id\" : title }\n\n\n    def append_atom_site(self, \n                        group_PDB, id, \n                        type_symbol, \n                        label_atom_id, \n                        label_alt_id, \n                        label_comp_id,\n                        label_asym_id, \n                        label_entity_id, \n                        label_seq_id, \n                        pdbx_PDB_ins_code, \n                        Cartn_x, \n                        Cartn_y, \n                        Cartn_z,\n                        occupancy, \n                        B_iso_or_equiv, \n                        pdbx_formal_charge, \n                        auth_seq_id, \n                        auth_comp_id, \n                        auth_asym_id, \n                        auth_atom_id, \n                        pdbx_PDB_model_num):\n\n        \"\"\"Add mmcif _atom_site \"\"\"\n\n        if self.mmcif[\"_atom_site\"] :\n            self.mmcif[\"_atom_site\"][\"group_PDB\"].append(group_PDB)\n            self.mmcif[\"_atom_site\"][\"id\"].append(id)\n            self.mmcif[\"_atom_site\"][\"type_symbol\"].append(type_symbol)\n            self.mmcif[\"_atom_site\"][\"label_atom_id\"].append(label_atom_id)\n            self.mmcif[\"_atom_site\"][\"label_alt_id\"].append(label_alt_id)\n            self.mmcif[\"_atom_site\"][\"label_comp_id\"].append(label_comp_id)\n            self.mmcif[\"_atom_site\"][\"label_asym_id\"].append(label_asym_id)\n            self.mmcif[\"_atom_site\"][\"label_entity_id\"].append(label_entity_id)\n            self.mmcif[\"_atom_site\"][\"label_seq_id\"].append(label_seq_id)\n            self.mmcif[\"_atom_site\"][\"pdbx_PDB_ins_code\"].append(pdbx_PDB_ins_code)\n            self.mmcif[\"_atom_site\"][\"Cartn_x\"].append(Cartn_x)\n            self.mmcif[\"_atom_site\"][\"Cartn_y\"].append(Cartn_y)\n            self.mmcif[\"_atom_site\"][\"Cartn_z\"].append(Cartn_z)\n            self.mmcif[\"_atom_site\"][\"occupancy\"].append(occupancy)\n            self.mmcif[\"_atom_site\"][\"B_iso_or_equiv\"].append(B_iso_or_equiv)\n            self.mmcif[\"_atom_site\"][\"pdbx_formal_charge\"].append(pdbx_formal_charge)\n            self.mmcif[\"_atom_site\"][\"auth_seq_id\"].append(auth_seq_id)\n            self.mmcif[\"_atom_site\"][\"auth_comp_id\"].append(auth_comp_id)\n            self.mmcif[\"_atom_site\"][\"auth_asym_id\"].append(auth_asym_id)\n            self.mmcif[\"_atom_site\"][\"auth_atom_id\"].append(auth_atom_id)\n            self.mmcif[\"_atom_site\"][\"pdbx_PDB_model_num\"].append(pdbx_PDB_model_num)\n        else:\n            self.mmcif[\"_atom_site\"] = {\n                \"group_PDB\" : [ group_PDB ],\n                \"id\" : [ id ],\n                \"type_symbol\" : [ type_symbol ],\n                \"label_atom_id\" : [ label_atom_id ],\n                \"label_alt_id\" : [ label_alt_id ],\n                \"label_comp_id\" : [ label_comp_id ],\n                \"label_asym_id\" : [ label_asym_id ],\n                \"label_entity_id\" : [ label_entity_id ],\n                \"label_seq_id\" : [ label_seq_id ],\n                \"pdbx_PDB_ins_code\" : [ pdbx_PDB_ins_code ],\n                \"Cartn_x\" : [ Cartn_x ],\n                \"Cartn_y\" : [ Cartn_y ],\n                \"Cartn_z\" : [ Cartn_z ],\n                \"occupancy\" : [ occupancy ],\n                \"B_iso_or_equiv\" : [ B_iso_or_equiv ],\n                \"pdbx_formal_charge\" : [ pdbx_formal_charge ],\n                \"auth_seq_id\" : [ auth_seq_id ],\n                \"auth_comp_id\" : [ auth_comp_id ],\n                \"auth_asym_id\" : [ auth_asym_id ],\n                \"auth_atom_id\" : [ auth_atom_id ],\n                \"pdbx_PDB_model_num\" : [ pdbx_PDB_model_num ],\n            }\n\n\n    def append_chem_comp_bond(self, chem_comp_id, i, j, k):\n        \"\"\" add chem_comp_bond \"\"\"\n        p = self.mmcif[\"_atom_site\"][\"label_atom_id\"][self.mmcif[\"_atom_site\"][\"id\"].index(i)]\n        q = self.mmcif[\"_atom_site\"][\"label_atom_id\"][self.mmcif[\"_atom_site\"][\"id\"].index(j)]\n        if self.mmcif[\"_chem_comp_bond\"]:\n            self.mmcif[\"_chem_comp_bond\"][\"comp_id\"].append(chem_comp_id)\n            self.mmcif[\"_chem_comp_bond\"][\"atom_id_1\"].append(p)\n            self.mmcif[\"_chem_comp_bond\"][\"atom_id_2\"].append(q)\n            self.mmcif[\"_chem_comp_bond\"][\"value_order\"].append(k)\n        else:\n            self.mmcif[\"_chem_comp_bond\"] = {\n                \"comp_id\" : [ chem_comp_id ],\n                \"atom_id_1\" : [ p ],\n                \"atom_id_2\" : [ q ],\n                \"value_order\" : [ k ],\n            }\n\n\n    def new_chem_comp(self):\n        \"\"\" start a new chem_comp entry \"\"\"\n        if not type(self.mmcif[\"_entry\"][\"id\"]) == list or len(self.mmcif[\"_entry\"][\"id\"]) &lt;= 2:\n            self.chem_comp_id = \"LIG\"\n        else:\n            self.chem_comp_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(3))\n        self.chem_comp_chainId = [ c for c in string.ascii_uppercase if not (c in self.usedId)][0]\n        self.chem_comp_resSeq = 100\n        self.usedId[self.chem_comp_chainId] = []\n        return self.chem_comp_chainId, self.chem_comp_resSeq, self.chem_comp_id\n\n\n    def new_chem_comp_atom(self, obj, element):\n        \"\"\" create and return unique atom name \"\"\"\n        if \"s_m_pdb_atom_name\" in obj:\n            atom_name = obj[\"s_m_pdb_atom_name\"].strip()\n        else:\n            atom_name = \"{}{}\".format(element,1)\n        if not (atom_name in self.usedId[self.chem_comp_chainId]):\n            self.usedId[self.chem_comp_chainId].append(atom_name)\n            return atom_name\n        else:\n            for i in range(1,10000):\n                new_name = \"{}{}\".format(element,i)\n                if not (new_name in self.usedId[self.chem_comp_chainId]):\n                    self.usedId[self.chem_comp_chainId].append(new_name)\n                    return new_name\n\n\n    def value_or_default(self, obj, k, default):\n        \"\"\" return value or default \"\"\"\n        v = None\n        if k in obj:\n            if type(obj[k]) == str:\n                v = obj[k].strip()\n        if v is None:\n            return default\n        else:\n            return v\n\n\n    def to_mmcif(self):\n        token = None\n        entity_id = 0\n        for line in self.contents:\n            line = line.strip()\n\n            if not line or line.startswith(\"#\"): \n                continue\n\n            # f_m_ct block\n            if line.startswith(\"f_m_ct {\"):\n                token = 'f_m_ct_key'\n                natoms = 0\n                nbonds = 0\n                entity_id += 1\n                k = []\n                continue\n            if token == 'f_m_ct_key':\n                if line.startswith(\":::\"): # end of f_m_ct key block\n                    n = len(k)\n                    token = 'f_m_ct_val'\n                    v = []\n                    continue\n                k.append(line)\n            if token == 'f_m_ct_val':\n                v.append(line)\n                if len(v) == n:\n                    data = dict(zip(k,v))\n                    if \"s_lp_Variant\" in data:\n                        self.title = data['s_lp_Variant'].replace('\"','').replace(\"'\",\"\")\n                    else:\n                        self.title = data['s_m_title'].replace('\"','').replace(\"'\",\"\")\n                    self.append_entry(self.title)\n                    token = None\n\n\n            # m_atom block\n            if line.startswith(\"m_atom\") :\n                natoms = int(self.count.findall(line)[0])\n                token = 'm_atom_key'\n                k = ['i_atom_index'] # 1st column is atom_index\n                continue\n            if token == 'm_atom_key':\n                if line.startswith(\":::\"):\n                    token = 'm_atom_val'\n                    nv = 0\n                    m_atom = {}\n                    m_atom_resName = {}\n                    continue\n                k.append(line)\n            if token == 'm_atom_val':\n                v = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n                data = dict(zip(k,v))\n\n                # build hierarchical structure of chain/ resSeq/ resName\n                chainId = self.value_or_default(data,\"s_m_chain_name\", \"A\")\n                resSeq = int(self.value_or_default(data, \"i_m_residue_number\", 1))\n                resName = self.value_or_default(data, \"s_m_pdb_residue_name\", \"?\")\n                if resName in self.std_rename:\n                    resName = self.std_rename[resName]\n                if not chainId in m_atom:\n                    m_atom[chainId] = {}\n                if not resSeq in m_atom[chainId]:\n                    m_atom[chainId][resSeq] = {}\n                if not resName in m_atom[chainId][resSeq]:\n                    m_atom[chainId][resSeq][resName] = []\n                m_atom[chainId][resSeq][resName].append(data)\n                m_atom_resName[int(data[\"i_atom_index\"])] = resName\n\n                nv += 1\n                if nv == natoms: # end of m_atom block\n                    token = None\n\n            \"\"\" m_bond block \"\"\"\n            if line.startswith(\"m_bond\") :\n                nbonds = int(self.count.findall(line)[0])\n                token = 'm_bond_key'\n                k = ['i_bond_index']\n                continue\n            if token == 'm_bond_key':\n                if line.startswith(\":::\"): # end of m_bond key block\n                    token = 'm_bond_val'\n                    nv = 0\n                    m_bond = {}\n                    continue\n                k.append(line)\n            if token == 'm_bond_val':\n                v = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n                data = dict(zip(k,v))\n\n                # build bond connectivity\n                p = int(data[\"i_m_from\"]) \n                q = int(data[\"i_m_to\"]) \n                r = int(data[\"i_m_order\"])\n                if p in m_bond:\n                    m_bond[p][q] = r\n                else:\n                    m_bond[p] = {q:r}\n                if q in m_bond:\n                    m_bond[q][p] = r\n                else:\n                    m_bond[q] = {p:r}\n\n                nv += 1\n                if nv == nbonds: # m_bond block ends\n                    token = None\n\n                    # create mmcif _atom_site\n                    for chainId_ in sorted(m_atom):\n                        for resSeq_ in sorted(m_atom[chainId_]):\n                            for resName_ in sorted(m_atom[chainId_][resSeq_]):\n                                if resName_ in self.std_residues:\n                                    group_PDB = \"ATOM\"\n                                    chainId, resSeq, resName = chainId_, resSeq_, resName_\n                                else:\n                                    group_PDB = \"HETATM\"\n                                    # check if new_chem_comp is necessary\n                                    this_residue = [ int(d[\"i_atom_index\"]) for d in m_atom[chainId_][resSeq_][resName_] ]\n                                    need_new_chem_comp = True\n                                    for p_ in this_residue:\n                                        for q_, bond_order in m_bond[p_].items():\n                                            if  (not (q_ in this_residue)) and \\\n                                                (not (m_atom_resName[q_] in self.std_residues)) and \\\n                                                (q_ in self.iamap):\n                                                # do not create another chem_comp\n                                                need_new_chem_comp = False\n                                                q, chainId, resSeq, resName = self.iamap[q_]\n                                                break\n                                    if need_new_chem_comp:\n                                        chainId, resSeq, resName = self.new_chem_comp()\n\n                                # go through all atoms within the same residue\n                                for d in m_atom[chainId_][resSeq_][resName_]:\n                                    self.serial += 1\n                                    self.iamap[int(d[\"i_atom_index\"])] = (self.serial, chainId, resSeq, resName)\n                                    element = self.atomic_symbol[int(d[\"i_m_atomic_number\"])]\n                                    if group_PDB == \"ATOM\":\n                                        name = self.value_or_default(d,\"s_m_pdb_atom_name\", \"?\")\n                                    else:\n                                        name = self.new_chem_comp_atom(d, element) \n                                    x = float(d[\"r_m_x_coord\"])\n                                    y = float(d[\"r_m_y_coord\"])\n                                    z = float(d[\"r_m_z_coord\"])\n                                    occupancy = float(self.value_or_default(d,\"r_m_pdb_occupancy\",1))\n                                    bfactor = float(self.value_or_default(d,\"r_m_pdb_tfactor\", 0))\n                                    formal_charge = int(self.value_or_default(d,\"i_m_formal_charge\", 0))\n                                    self.append_atom_site(\n                                        group_PDB = group_PDB, \n                                        id = self.serial,\n                                        type_symbol = element,\n                                        label_atom_id = name,\n                                        label_alt_id = \".\",\n                                        label_comp_id = resName,\n                                        label_asym_id = chainId,\n                                        label_entity_id = entity_id,\n                                        label_seq_id = resSeq,\n                                        pdbx_PDB_ins_code = \"?\",\n                                        Cartn_x = x,\n                                        Cartn_y = y,\n                                        Cartn_z = z,\n                                        occupancy = occupancy,\n                                        B_iso_or_equiv = bfactor,\n                                        pdbx_formal_charge = formal_charge,\n                                        auth_seq_id = resSeq,\n                                        auth_comp_id = resName,\n                                        auth_asym_id = chainId,\n                                        auth_atom_id = name,\n                                        pdbx_PDB_model_num = 1,\n                                    )\n\n                    # create mmcif _chem_comp_bond\n                    for chainId_ in sorted(m_atom):\n                        for resSeq_ in sorted(m_atom[chainId_]):\n                            for resName_ in sorted(m_atom[chainId_][resSeq_]):\n                                if not (resName_ in self.std_residues): # HETATM\n                                    for d in m_atom[chainId_][resSeq_][resName_]:\n                                        p_ = int(d[\"i_atom_index\"])\n                                        p, p_chainId, p_resSeq, p_resName = self.iamap[p_]\n                                        if p_ in m_bond:\n                                            for q_, bond_order in m_bond[p_].items():\n                                                q, q_chainId, q_resSeq, q_resName = self.iamap[q_]\n                                                self.append_chem_comp_bond(p_resName, p, q, bond_order)\n\n        cifo = CifFileWriter(\"{}.cif\".format(self.prefix))\n\n        # clean up undefined dictionary\n        # force to copy a list to avoid \n        # RuntimeError: dictionary changed size during iteration\n        for k in list(self.mmcif): \n            if not self.mmcif[k]:\n                del self.mmcif[k]\n\n        cifo.write({ \"desmondtools\" : self.mmcif })\n\n\n    def debug_dict(self, data):\n        for k in data:\n            print(\"%-30s %-s\" % (k,data[k]))\n\n\n    def PDB_ATOM_FORMAT(self, \n                        data_vector:List[Dict[str, Any]], \n                        default_resName:str=\"UNL\", \n                        default_chainId:str=\"X\") -&gt; List[str]:\n        \"\"\"\n        PDB format:\n            COLUMNS        DATA  TYPE    FIELD        DEFINITION\n            -------------------------------------------------------------------------------------\n            1 -  6        Record name   \"ATOM  \" or \"HETATM\"\n            7 - 11        Integer       serial       Atom  serial number.\n            13 - 16        Atom          name         Atom name.\n            17             Character     altLoc       Alternate location indicator.\n            18 - 20        Residue name  resName      Residue name.\n            22             Character     chainID      Chain identifier.\n            23 - 26        Integer       resSeq       Residue sequence number.\n            27             AChar         iCode        Code for insertion of residues.\n            31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms.\n            39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms.\n            47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms.\n            55 - 60        Real(6.2)     occupancy    Occupancy.\n            61 - 66        Real(6.2)     tempFactor   Temperature  factor.\n            77 - 78        LString(2)    element      Element symbol, right-justified.\n            79 - 80        LString(2)    charge       Charge  on the atom.\n        \"\"\"\n        pdblines = \"\"\n        for data in data_vector:\n            try:\n                assert data[\"s_m_pdb_residue_name\"].strip() in self.std_rename\n                keyword = \"ATOM\"\n            except:\n                keyword = \"HETATM\"\n            try:\n                serial = int(data['i_pdb_PDB_serial'])\n            except:\n                serial = int(data['atom_index'])\n            try:\n                chainId = data['s_m_chain_name']\n            except:\n                chainId = default_chainId\n            try:\n                altLoc = data['s_pdb_altloc_chars'][0]\n            except:\n                altLoc = \" \"\n            try:\n                name = data['s_m_pdb_atom_name']\n            except:\n                try:\n                    atom_number = int(data['i_m_atomic_number'])\n                    atom_index = int(data['atom_index'])\n                    name = self.atomic_symbol[atom_number] + str(atom_index)\n                except:\n                    self.debug_dict(data)\n                    sys.exit(1)\n            try:\n                resName = data['s_m_pdb_residue_name']\n            except:\n                resName = default_resName\n\n            resSeq = int(self.value_or_default(data, 'i_m_residue_number', 1))\n            x = float(data['r_m_x_coord'])\n            y = float(data['r_m_y_coord'])\n            z = float(data['r_m_z_coord'])\n            try:\n                occupancy = \"%6.2f\" % float(self.value_or_default(data, 'r_m_pdb_occupancy', 1.0))\n            except:\n                occupancy = \"%6.2f\" % 1.0\n            try:\n                tempFactor = \"%6.2f\" % float(self.value_or_default(data, 'r_m_pdb_tfactor', 0.0))\n            except:\n                tempFactor = \"%6.2f\" % 0.0\n            try:\n                element = self.atomic_symbol[int(data['i_m_atomic_number'])]\n            except:\n                element = \"  \"\n            try:\n                ch = int(data['i_m_formal_charge'])\n                if ch == 0:\n                    charge = \"  \"\n                elif ch &gt; 0:\n                    charge = \"%d+\" % ch\n                elif ch &lt; 0:\n                    charge = \"%d-\" % ch\n            except:\n                charge = \"  \"\n            iCode = \" \"\n            blank = \" \"*11\n\n            line = \"{:&lt;6s}{:5d} {:4s}{:1s}{:4s}{:1s}{:4d}{:1s}   {:8.3f}{:8.3f}{:8.3f}{}{}{}{}{}\".format(\n                    keyword, serial, name, altLoc, resName, chainId, resSeq, iCode,\n                    x, y, z, occupancy, tempFactor, blank, element, charge,\n                )\n            pdblines += (line + \"\\n\")\n        return pdblines\n\n\n    @staticmethod\n    def PDB_CONECT_FORMAT(v:Dict[str, Any]) -&gt; List[str]:\n        \"\"\"\n        PDB format:\n            COLUMNS       DATA  TYPE      FIELD        DEFINITION\n            -------------------------------------------------------------------------\n            1 -  6        Record name    \"CONECT\"\n            7 - 11       Integer        serial       Atom  serial number\n            12 - 16        Integer        serial       Serial number of bonded atom\n            17 - 21        Integer        serial       Serial  number of bonded atom\n            22 - 26        Integer        serial       Serial number of bonded atom\n            27 - 31        Integer        serial       Serial number of bonded atom\n        \"\"\"\n        keyword=\"CONECT\"\n        bonded = {}\n        for d in v:\n            i = int(d['i_m_from'])\n            j = int(d['i_m_to'])\n            if i in bonded:\n                bonded[i].append(j)\n            else:\n                bonded[i] = [j]\n            if j in bonded:\n                bonded[j].append(i)\n            else:\n                bonded[j] = [i]\n        pdblines = \"\"\n        for i in sorted(bonded):\n            bonded_serials = \"\"\n            for j in sorted(bonded[i]):\n                bonded_serials += \"{:5d}\".format(j)\n            pdblines += \"{:&lt;6s}{:5d}{}\\n\".format(keyword, i, bonded_serials)\n        return pdblines\n\n\n    @staticmethod\n    def PDB_MODEL_FORMAT(serial:int) -&gt; str:\n        \"\"\"\n        PDB format:\n            COLUMNS        DATA  TYPE    FIELD          DEFINITION\n            ---------------------------------------------------------------------------------------\n            1 -  6        Record name   \"MODEL \"\n            11 - 14        Integer       serial         Model serial number.\n        \"\"\"\n        return \"{:&lt;6s}     {:4d}\".format(\"MODEL\", serial)\n\n\n    def to_pdb_contents(self, first_entry_coord_only=True) -&gt; Dict:\n        count = re.compile(r'\\[(\\d+)\\]')\n        content = {}\n        entry_number = 0\n        q = None\n        for line in self.contents:\n            line = line.strip()\n            if not line or line.startswith(\"#\"): continue\n            # parse f_m_ct\n            if line.startswith(\"f_m_ct {\"):\n                q = 'f_m_ct_key'\n                entry_number += 1\n                natoms = 0\n                nbonds = 0\n                k = []\n                continue\n            if q == 'f_m_ct_key' and line.startswith(\":::\"):\n                n = len(k)\n                q = 'f_m_ct_val'\n                vm = []\n                va = []\n                vb = []\n                continue\n            if q == 'f_m_ct_key': k.append(line)\n            if q == 'f_m_ct_val':\n                vm.append(line)\n                if len(vm) == n:\n                    data = dict(zip(k,vm))\n                    q = None\n                    title = data['s_m_title'].replace('\"','').replace(\"'\",\"\")\n                    content[title] = data\n\n            if line.startswith(\"m_atom\") :\n                natoms = int(count.findall(line)[0])\n                q = 'm_atom_key'\n                k = ['atom_index']\n                continue\n            if q == 'm_atom_key' and line.startswith(\":::\"):\n                q = 'm_atom_val'\n                nv = 0\n                continue\n            if q == 'm_atom_key': k.append(line)\n            if q == 'm_atom_val':\n                c = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n                data = dict(zip(k,c))\n                nv += 1\n                va.append(data)\n                if nv == natoms:\n                    q = None\n                    if (first_entry_coord_only and entry_number == 1) or \\\n                        (not first_entry_coord_only):\n                        content[title]['pdb'] = \\\n                        Maestro.PDB_MODEL_FORMAT(entry_number) + \"\\n\" + \\\n                        self.PDB_ATOM_FORMAT(va)\n\n            if line.startswith(\"m_bond\") :\n                nbonds = int(count.findall(line)[0])\n                q = 'm_bond_key'\n                k = ['bond_index']\n                continue\n            if q == 'm_bond_key' and line.startswith(\":::\"):\n                q = 'm_bond_val'\n                nv = 0\n                continue\n            if q == 'm_bond_key': k.append(line)\n            if q == 'm_bond_val':\n                c = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n                data = dict(zip(k,c))\n                # conect information only for ligands\n                if not 'i_glide_grid_version' in content[title] :\n                    vb.append(data)\n                nv += 1\n                if nv == nbonds:\n                    q = None\n                    if (first_entry_coord_only and entry_number == 1) or \\\n                        (not first_entry_coord_only):\n                        if vb:\n                            content[title]['pdb'] += Maestro.PDB_CONECT_FORMAT(vb)\n                        content[title]['pdb'] += 'ENDMDL\\nEND'\n        return content\n\n\n    def to_pdb(self, first_entry_coord_only=True) -&gt; None:\n        content = self.to_pdb_contents(first_entry_coord_only)\n        with open(f\"{self.prefix}.pdb\", \"w\") as f:\n            for k, v in content.items():\n                for kk, vv in v.items():\n                    if kk == \"pdb\":\n                        f.write(vv)\n\n\n    @staticmethod\n    def getFromDict(dataDict, mapList):\n        return reduce(operator.getitem, mapList, dataDict)\n\n\n    @staticmethod\n    def setInDict(dataDict, mapList, value):\n        if mapList:\n            Maestro.getFromDict(dataDict, mapList[:-1])[mapList[-1]] = value\n        else:\n            for k,v in value.items():\n                dataDict[k] = v\n\n\n    @staticmethod\n    def convert_maegz_to_dict(filename):\n        count = re.compile(r'(\\w+)\\[(\\d+)\\]')\n        DATA = []\n        with gzip.open(filename,\"rt\") as f:\n            tokens = shlex.split(f.read())\n            level = []\n            data = {}\n            previous_token = None\n            header = False\n            extra_column = 0\n            num_repeat = 1\n            skip = False\n            for token in tokens :\n                if token == \"#\" :\n                    skip = not skip # invert\n                    continue\n                elif skip:\n                    continue\n                elif token == \"{\" :\n                    header = True\n                    key = []\n                    val = []\n                    arr = []\n                    if previous_token:\n                        if previous_token == \"f_m_ct\" and data:\n                            DATA.append(data)\n                            data = {}\n                        try:\n                            (block, num_repeat) = count.findall(previous_token)[0]\n                            num_repeat = int(num_repeat)\n                            extra_column = 1\n                        except:\n                            block = previous_token\n                            num_repeat = 1\n                            extra_column = 0\n                        level.append(block)\n\n                elif token == \"}\":\n                    if level: \n                        level.pop()\n                elif token == \":::\":\n                    header = False\n                elif header:\n                    key.append(token)\n                else:\n                    val.append(token)\n                    # only store f_m_ct blocks (level != [])\n                    if len(val) == (len(key)+extra_column) and level :\n                        arr.append(val[extra_column:])\n                        val = []\n                        if len(arr) == num_repeat:\n                            if len(arr) == 1:\n                                Maestro.setInDict(data,level,dict(zip(key,arr[0])))\n                            else:\n                                T = list(zip(*arr)) # transpose\n                                Maestro.setInDict(data,level,dict(zip(key,T)))\n                previous_token = token\n\n        if data:\n            DATA.append(data)\n\n        return DATA\n</code></pre>"},{"location":"index.html#desmondtools.Maestro-attributes","title":"Attributes","text":""},{"location":"index.html#desmondtools.Maestro.atomic_symbol","title":"<code>atomic_symbol = {1: 'H', 2: 'He', 3: 'Li', 4: 'Be', 5: 'B', 6: 'C', 7: 'N', 8: 'O', 9: 'F', 10: 'Ne', 11: 'Na', 12: 'Mg', 13: 'Al', 14: 'Si', 15: 'P', 16: 'S', 17: 'Cl', 18: 'Ar', 19: 'K', 20: 'Ca', 21: 'Sc', 22: 'Ti', 23: 'V', 24: 'Cr', 25: 'Mn', 26: 'Fe', 27: 'Co', 28: 'Ni', 29: 'Cu', 30: 'Zn', 31: 'Ga', 32: 'Ge', 33: 'As', 34: 'Se', 35: 'Br', 36: 'Kr', 37: 'Rb', 38: 'Sr', 39: 'Y', 40: 'Zr', 41: 'Nb', 42: 'Mo', 43: 'Tc', 44: 'Ru', 45: 'Rh', 46: 'Pd', 47: 'Ag', 48: 'Cd', 49: 'In', 50: 'Sn', 51: 'Sb', 52: 'Te', 53: 'I', 54: 'Xe', 55: 'Cs', 56: 'Ba', 57: 'La', 58: 'Ce', 59: 'Pr', 60: 'Nd', 61: 'Pm', 62: 'Sm', 63: 'Eu', 64: 'Gd', 65: 'Tb', 66: 'Dy', 67: 'Ho', 68: 'Er', 69: 'Tm', 70: 'Yb', 71: 'Lu', 72: 'Hf', 73: 'Ta', 74: 'W', 75: 'Re', 76: 'Os', 77: 'Ir', 78: 'Pt', 79: 'Au', 80: 'Hg', 81: 'Tl', 82: 'Pb', 83: 'Bi', 84: 'Po', 85: 'At', 86: 'Rn', 87: 'Fr', 88: 'Ra', 89: 'Ac', 90: 'Th', 91: 'Pa', 92: 'U', 93: 'Np', 94: 'Pu', 95: 'Am', 96: 'Cm', 97: 'Bk', 98: 'Cf', 99: 'Es', 100: 'Fm', 101: 'Md', 102: 'No', 103: 'Lr', 104: 'Rf', 105: 'Db', 106: 'Sg', 107: 'Bh', 108: 'Hs', 109: 'Mt', 110: 'Ds', 111: 'Rg', 112: 'Cn', 113: 'Nh', 114: 'Fl', 115: 'Mc', 116: 'Lv', 117: 'Ts', 118: 'Og'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.contents","title":"<code>contents = f.readlines()</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.count","title":"<code>count = re.compile('\\\\[(\\\\d+)\\\\]')</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.filename","title":"<code>filename = filename</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.iamap","title":"<code>iamap = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.max_two_entries","title":"<code>max_two_entries = max_two_entries</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.mmcif","title":"<code>mmcif = {'_entry': None, '_chem_comp_bond': None, '_atom_site': None}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.prefix","title":"<code>prefix = None</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.serial","title":"<code>serial = 0</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.std_rename","title":"<code>std_rename = {'URI': 'URA', 'CYX': 'CYS', 'CYM': 'CYS', 'HID': 'HIS', 'HIE': 'HIS', 'HIP': 'HIS'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.std_residues","title":"<code>std_residues = ['ADE', 'GUA', 'CYT', 'URA', 'THY', 'ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU', 'GLY', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE', 'PRO', 'SER', 'THR', 'TRP', 'TYR', 'VAL']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.title","title":"<code>title = ''</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro.usedId","title":"<code>usedId = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Maestro-functions","title":"Functions","text":""},{"location":"index.html#desmondtools.Maestro.PDB_ATOM_FORMAT","title":"<code>PDB_ATOM_FORMAT(data_vector, default_resName='UNL', default_chainId='X')</code>","text":"PDB format Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def PDB_ATOM_FORMAT(self, \n                    data_vector:List[Dict[str, Any]], \n                    default_resName:str=\"UNL\", \n                    default_chainId:str=\"X\") -&gt; List[str]:\n    \"\"\"\n    PDB format:\n        COLUMNS        DATA  TYPE    FIELD        DEFINITION\n        -------------------------------------------------------------------------------------\n        1 -  6        Record name   \"ATOM  \" or \"HETATM\"\n        7 - 11        Integer       serial       Atom  serial number.\n        13 - 16        Atom          name         Atom name.\n        17             Character     altLoc       Alternate location indicator.\n        18 - 20        Residue name  resName      Residue name.\n        22             Character     chainID      Chain identifier.\n        23 - 26        Integer       resSeq       Residue sequence number.\n        27             AChar         iCode        Code for insertion of residues.\n        31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms.\n        39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms.\n        47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms.\n        55 - 60        Real(6.2)     occupancy    Occupancy.\n        61 - 66        Real(6.2)     tempFactor   Temperature  factor.\n        77 - 78        LString(2)    element      Element symbol, right-justified.\n        79 - 80        LString(2)    charge       Charge  on the atom.\n    \"\"\"\n    pdblines = \"\"\n    for data in data_vector:\n        try:\n            assert data[\"s_m_pdb_residue_name\"].strip() in self.std_rename\n            keyword = \"ATOM\"\n        except:\n            keyword = \"HETATM\"\n        try:\n            serial = int(data['i_pdb_PDB_serial'])\n        except:\n            serial = int(data['atom_index'])\n        try:\n            chainId = data['s_m_chain_name']\n        except:\n            chainId = default_chainId\n        try:\n            altLoc = data['s_pdb_altloc_chars'][0]\n        except:\n            altLoc = \" \"\n        try:\n            name = data['s_m_pdb_atom_name']\n        except:\n            try:\n                atom_number = int(data['i_m_atomic_number'])\n                atom_index = int(data['atom_index'])\n                name = self.atomic_symbol[atom_number] + str(atom_index)\n            except:\n                self.debug_dict(data)\n                sys.exit(1)\n        try:\n            resName = data['s_m_pdb_residue_name']\n        except:\n            resName = default_resName\n\n        resSeq = int(self.value_or_default(data, 'i_m_residue_number', 1))\n        x = float(data['r_m_x_coord'])\n        y = float(data['r_m_y_coord'])\n        z = float(data['r_m_z_coord'])\n        try:\n            occupancy = \"%6.2f\" % float(self.value_or_default(data, 'r_m_pdb_occupancy', 1.0))\n        except:\n            occupancy = \"%6.2f\" % 1.0\n        try:\n            tempFactor = \"%6.2f\" % float(self.value_or_default(data, 'r_m_pdb_tfactor', 0.0))\n        except:\n            tempFactor = \"%6.2f\" % 0.0\n        try:\n            element = self.atomic_symbol[int(data['i_m_atomic_number'])]\n        except:\n            element = \"  \"\n        try:\n            ch = int(data['i_m_formal_charge'])\n            if ch == 0:\n                charge = \"  \"\n            elif ch &gt; 0:\n                charge = \"%d+\" % ch\n            elif ch &lt; 0:\n                charge = \"%d-\" % ch\n        except:\n            charge = \"  \"\n        iCode = \" \"\n        blank = \" \"*11\n\n        line = \"{:&lt;6s}{:5d} {:4s}{:1s}{:4s}{:1s}{:4d}{:1s}   {:8.3f}{:8.3f}{:8.3f}{}{}{}{}{}\".format(\n                keyword, serial, name, altLoc, resName, chainId, resSeq, iCode,\n                x, y, z, occupancy, tempFactor, blank, element, charge,\n            )\n        pdblines += (line + \"\\n\")\n    return pdblines\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.PDB_ATOM_FORMAT--columns-data-type-field-definition","title":"COLUMNS        DATA  TYPE    FIELD        DEFINITION","text":"<p>1 -  6        Record name   \"ATOM  \" or \"HETATM\" 7 - 11        Integer       serial       Atom  serial number. 13 - 16        Atom          name         Atom name. 17             Character     altLoc       Alternate location indicator. 18 - 20        Residue name  resName      Residue name. 22             Character     chainID      Chain identifier. 23 - 26        Integer       resSeq       Residue sequence number. 27             AChar         iCode        Code for insertion of residues. 31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms. 39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms. 47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms. 55 - 60        Real(6.2)     occupancy    Occupancy. 61 - 66        Real(6.2)     tempFactor   Temperature  factor. 77 - 78        LString(2)    element      Element symbol, right-justified. 79 - 80        LString(2)    charge       Charge  on the atom.</p>"},{"location":"index.html#desmondtools.Maestro.PDB_CONECT_FORMAT","title":"<code>PDB_CONECT_FORMAT(v)</code>  <code>staticmethod</code>","text":"PDB format Source code in <code>src/desmondtools/maestro.py</code> <pre><code>@staticmethod\ndef PDB_CONECT_FORMAT(v:Dict[str, Any]) -&gt; List[str]:\n    \"\"\"\n    PDB format:\n        COLUMNS       DATA  TYPE      FIELD        DEFINITION\n        -------------------------------------------------------------------------\n        1 -  6        Record name    \"CONECT\"\n        7 - 11       Integer        serial       Atom  serial number\n        12 - 16        Integer        serial       Serial number of bonded atom\n        17 - 21        Integer        serial       Serial  number of bonded atom\n        22 - 26        Integer        serial       Serial number of bonded atom\n        27 - 31        Integer        serial       Serial number of bonded atom\n    \"\"\"\n    keyword=\"CONECT\"\n    bonded = {}\n    for d in v:\n        i = int(d['i_m_from'])\n        j = int(d['i_m_to'])\n        if i in bonded:\n            bonded[i].append(j)\n        else:\n            bonded[i] = [j]\n        if j in bonded:\n            bonded[j].append(i)\n        else:\n            bonded[j] = [i]\n    pdblines = \"\"\n    for i in sorted(bonded):\n        bonded_serials = \"\"\n        for j in sorted(bonded[i]):\n            bonded_serials += \"{:5d}\".format(j)\n        pdblines += \"{:&lt;6s}{:5d}{}\\n\".format(keyword, i, bonded_serials)\n    return pdblines\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.PDB_CONECT_FORMAT--columns-data-type-field-definition","title":"COLUMNS       DATA  TYPE      FIELD        DEFINITION","text":"<p>1 -  6        Record name    \"CONECT\" 7 - 11       Integer        serial       Atom  serial number 12 - 16        Integer        serial       Serial number of bonded atom 17 - 21        Integer        serial       Serial  number of bonded atom 22 - 26        Integer        serial       Serial number of bonded atom 27 - 31        Integer        serial       Serial number of bonded atom</p>"},{"location":"index.html#desmondtools.Maestro.PDB_MODEL_FORMAT","title":"<code>PDB_MODEL_FORMAT(serial)</code>  <code>staticmethod</code>","text":"PDB format Source code in <code>src/desmondtools/maestro.py</code> <pre><code>@staticmethod\ndef PDB_MODEL_FORMAT(serial:int) -&gt; str:\n    \"\"\"\n    PDB format:\n        COLUMNS        DATA  TYPE    FIELD          DEFINITION\n        ---------------------------------------------------------------------------------------\n        1 -  6        Record name   \"MODEL \"\n        11 - 14        Integer       serial         Model serial number.\n    \"\"\"\n    return \"{:&lt;6s}     {:4d}\".format(\"MODEL\", serial)\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.PDB_MODEL_FORMAT--columns-data-type-field-definition","title":"COLUMNS        DATA  TYPE    FIELD          DEFINITION","text":"<p>1 -  6        Record name   \"MODEL \" 11 - 14        Integer       serial         Model serial number.</p>"},{"location":"index.html#desmondtools.Maestro.__init__","title":"<code>__init__(filename, max_two_entries=True)</code>","text":"<p>initialize</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def __init__(self, filename:str, max_two_entries:bool=True) -&gt; None:\n    \"\"\" initialize \"\"\"\n    if not Path(filename).exists:\n        print(f\"Error file not found: {filename}\")\n        sys.exit(1)\n\n    self.filename = filename\n    self.prefix = None\n    self.contents = None\n\n    if filename.endswith('.maegz'):\n        self.prefix = filename.replace(\".maegz\", \"\")\n        with gzip.open(filename, 'rt') as f:\n            self.contents = f.readlines()\n\n    elif filename.endswith('.mae.gz'):\n        self.prefix = filename.replace(\".mae.gz\", \"\")\n        with gzip.open(filename, \"rt\") as f:\n            self.contents = f.readlines()\n\n    elif filename.endswith('.mae'):\n        self.prefix = filename.replace(\".mae\", \"\")\n        with open(filename, \"rt\") as f:\n            self.contents = f.readlines()\n    else:\n        print(\"Error : .mae, .mae.gz, or .maegz file is expected\")\n        sys.exit(1)\n\n    self.max_two_entries = max_two_entries\n    self.count = re.compile(r'\\[(\\d+)\\]')\n    self.title = \"\"\n    self.serial = 0\n    self.usedId = {}\n    self.mmcif = {\n        \"_entry\": None, \n        \"_chem_comp_bond\": None, \n        \"_atom_site\": None,\n        } # mmcif-like object\n    self.iamap = {}\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.append_atom_site","title":"<code>append_atom_site(group_PDB, id, type_symbol, label_atom_id, label_alt_id, label_comp_id, label_asym_id, label_entity_id, label_seq_id, pdbx_PDB_ins_code, Cartn_x, Cartn_y, Cartn_z, occupancy, B_iso_or_equiv, pdbx_formal_charge, auth_seq_id, auth_comp_id, auth_asym_id, auth_atom_id, pdbx_PDB_model_num)</code>","text":"<p>Add mmcif _atom_site</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def append_atom_site(self, \n                    group_PDB, id, \n                    type_symbol, \n                    label_atom_id, \n                    label_alt_id, \n                    label_comp_id,\n                    label_asym_id, \n                    label_entity_id, \n                    label_seq_id, \n                    pdbx_PDB_ins_code, \n                    Cartn_x, \n                    Cartn_y, \n                    Cartn_z,\n                    occupancy, \n                    B_iso_or_equiv, \n                    pdbx_formal_charge, \n                    auth_seq_id, \n                    auth_comp_id, \n                    auth_asym_id, \n                    auth_atom_id, \n                    pdbx_PDB_model_num):\n\n    \"\"\"Add mmcif _atom_site \"\"\"\n\n    if self.mmcif[\"_atom_site\"] :\n        self.mmcif[\"_atom_site\"][\"group_PDB\"].append(group_PDB)\n        self.mmcif[\"_atom_site\"][\"id\"].append(id)\n        self.mmcif[\"_atom_site\"][\"type_symbol\"].append(type_symbol)\n        self.mmcif[\"_atom_site\"][\"label_atom_id\"].append(label_atom_id)\n        self.mmcif[\"_atom_site\"][\"label_alt_id\"].append(label_alt_id)\n        self.mmcif[\"_atom_site\"][\"label_comp_id\"].append(label_comp_id)\n        self.mmcif[\"_atom_site\"][\"label_asym_id\"].append(label_asym_id)\n        self.mmcif[\"_atom_site\"][\"label_entity_id\"].append(label_entity_id)\n        self.mmcif[\"_atom_site\"][\"label_seq_id\"].append(label_seq_id)\n        self.mmcif[\"_atom_site\"][\"pdbx_PDB_ins_code\"].append(pdbx_PDB_ins_code)\n        self.mmcif[\"_atom_site\"][\"Cartn_x\"].append(Cartn_x)\n        self.mmcif[\"_atom_site\"][\"Cartn_y\"].append(Cartn_y)\n        self.mmcif[\"_atom_site\"][\"Cartn_z\"].append(Cartn_z)\n        self.mmcif[\"_atom_site\"][\"occupancy\"].append(occupancy)\n        self.mmcif[\"_atom_site\"][\"B_iso_or_equiv\"].append(B_iso_or_equiv)\n        self.mmcif[\"_atom_site\"][\"pdbx_formal_charge\"].append(pdbx_formal_charge)\n        self.mmcif[\"_atom_site\"][\"auth_seq_id\"].append(auth_seq_id)\n        self.mmcif[\"_atom_site\"][\"auth_comp_id\"].append(auth_comp_id)\n        self.mmcif[\"_atom_site\"][\"auth_asym_id\"].append(auth_asym_id)\n        self.mmcif[\"_atom_site\"][\"auth_atom_id\"].append(auth_atom_id)\n        self.mmcif[\"_atom_site\"][\"pdbx_PDB_model_num\"].append(pdbx_PDB_model_num)\n    else:\n        self.mmcif[\"_atom_site\"] = {\n            \"group_PDB\" : [ group_PDB ],\n            \"id\" : [ id ],\n            \"type_symbol\" : [ type_symbol ],\n            \"label_atom_id\" : [ label_atom_id ],\n            \"label_alt_id\" : [ label_alt_id ],\n            \"label_comp_id\" : [ label_comp_id ],\n            \"label_asym_id\" : [ label_asym_id ],\n            \"label_entity_id\" : [ label_entity_id ],\n            \"label_seq_id\" : [ label_seq_id ],\n            \"pdbx_PDB_ins_code\" : [ pdbx_PDB_ins_code ],\n            \"Cartn_x\" : [ Cartn_x ],\n            \"Cartn_y\" : [ Cartn_y ],\n            \"Cartn_z\" : [ Cartn_z ],\n            \"occupancy\" : [ occupancy ],\n            \"B_iso_or_equiv\" : [ B_iso_or_equiv ],\n            \"pdbx_formal_charge\" : [ pdbx_formal_charge ],\n            \"auth_seq_id\" : [ auth_seq_id ],\n            \"auth_comp_id\" : [ auth_comp_id ],\n            \"auth_asym_id\" : [ auth_asym_id ],\n            \"auth_atom_id\" : [ auth_atom_id ],\n            \"pdbx_PDB_model_num\" : [ pdbx_PDB_model_num ],\n        }\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.append_chem_comp_bond","title":"<code>append_chem_comp_bond(chem_comp_id, i, j, k)</code>","text":"<p>add chem_comp_bond</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def append_chem_comp_bond(self, chem_comp_id, i, j, k):\n    \"\"\" add chem_comp_bond \"\"\"\n    p = self.mmcif[\"_atom_site\"][\"label_atom_id\"][self.mmcif[\"_atom_site\"][\"id\"].index(i)]\n    q = self.mmcif[\"_atom_site\"][\"label_atom_id\"][self.mmcif[\"_atom_site\"][\"id\"].index(j)]\n    if self.mmcif[\"_chem_comp_bond\"]:\n        self.mmcif[\"_chem_comp_bond\"][\"comp_id\"].append(chem_comp_id)\n        self.mmcif[\"_chem_comp_bond\"][\"atom_id_1\"].append(p)\n        self.mmcif[\"_chem_comp_bond\"][\"atom_id_2\"].append(q)\n        self.mmcif[\"_chem_comp_bond\"][\"value_order\"].append(k)\n    else:\n        self.mmcif[\"_chem_comp_bond\"] = {\n            \"comp_id\" : [ chem_comp_id ],\n            \"atom_id_1\" : [ p ],\n            \"atom_id_2\" : [ q ],\n            \"value_order\" : [ k ],\n        }\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.append_entry","title":"<code>append_entry(title)</code>","text":"<p>Start a new entry.</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def append_entry(self, title):\n    \"\"\"Start a new entry.\"\"\"\n    if self.mmcif[\"_entry\"]:\n        if type(self.mmcif[\"_entry\"][\"id\"]) == list:\n            # you got here as the third and later entry\n            if self.max_two_entries:\n                # write out last two entries\n                self.write_mmcif()\n                # return to the state in which only the first entry was defined\n                self.mmcif = copy.deepcopy(self.mmcif_first)\n                self.usedId = copy.deepcopy(self.mmcif_first_usedId)\n                self.serial = self.mmcif_first_serial\n                # regardless of its appearance, current entry now is regarded as the second entry\n                self.mmcif[\"_entry\"][\"id\"] = [ self.mmcif[\"_entry\"][\"id\"][0], title ]\n            else:\n                # otherwise continue to add entry\n                self.mmcif[\"_entry\"][\"id\"].append(title)\n        else:\n            # you got here as the second entry\n            # save the first entry before adding the second entry\n            self.mmcif_first = copy.deepcopy(self.mmcif)\n            self.mmcif_first_usedId = copy.deepcopy(self.usedId)\n            self.mmcif_first_serial = self.serial\n            # change to a list type\n            self.mmcif[\"_entry\"][\"id\"] = [ self.mmcif[\"_entry\"][\"id\"], title ]\n    else:\n        # regular string type\n        self.mmcif[\"_entry\"] = { \"id\" : title }\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.convert_maegz_to_dict","title":"<code>convert_maegz_to_dict(filename)</code>  <code>staticmethod</code>","text":"Source code in <code>src/desmondtools/maestro.py</code> <pre><code>@staticmethod\ndef convert_maegz_to_dict(filename):\n    count = re.compile(r'(\\w+)\\[(\\d+)\\]')\n    DATA = []\n    with gzip.open(filename,\"rt\") as f:\n        tokens = shlex.split(f.read())\n        level = []\n        data = {}\n        previous_token = None\n        header = False\n        extra_column = 0\n        num_repeat = 1\n        skip = False\n        for token in tokens :\n            if token == \"#\" :\n                skip = not skip # invert\n                continue\n            elif skip:\n                continue\n            elif token == \"{\" :\n                header = True\n                key = []\n                val = []\n                arr = []\n                if previous_token:\n                    if previous_token == \"f_m_ct\" and data:\n                        DATA.append(data)\n                        data = {}\n                    try:\n                        (block, num_repeat) = count.findall(previous_token)[0]\n                        num_repeat = int(num_repeat)\n                        extra_column = 1\n                    except:\n                        block = previous_token\n                        num_repeat = 1\n                        extra_column = 0\n                    level.append(block)\n\n            elif token == \"}\":\n                if level: \n                    level.pop()\n            elif token == \":::\":\n                header = False\n            elif header:\n                key.append(token)\n            else:\n                val.append(token)\n                # only store f_m_ct blocks (level != [])\n                if len(val) == (len(key)+extra_column) and level :\n                    arr.append(val[extra_column:])\n                    val = []\n                    if len(arr) == num_repeat:\n                        if len(arr) == 1:\n                            Maestro.setInDict(data,level,dict(zip(key,arr[0])))\n                        else:\n                            T = list(zip(*arr)) # transpose\n                            Maestro.setInDict(data,level,dict(zip(key,T)))\n            previous_token = token\n\n    if data:\n        DATA.append(data)\n\n    return DATA\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.debug_dict","title":"<code>debug_dict(data)</code>","text":"Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def debug_dict(self, data):\n    for k in data:\n        print(\"%-30s %-s\" % (k,data[k]))\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.getFromDict","title":"<code>getFromDict(dataDict, mapList)</code>  <code>staticmethod</code>","text":"Source code in <code>src/desmondtools/maestro.py</code> <pre><code>@staticmethod\ndef getFromDict(dataDict, mapList):\n    return reduce(operator.getitem, mapList, dataDict)\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.new_chem_comp","title":"<code>new_chem_comp()</code>","text":"<p>start a new chem_comp entry</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def new_chem_comp(self):\n    \"\"\" start a new chem_comp entry \"\"\"\n    if not type(self.mmcif[\"_entry\"][\"id\"]) == list or len(self.mmcif[\"_entry\"][\"id\"]) &lt;= 2:\n        self.chem_comp_id = \"LIG\"\n    else:\n        self.chem_comp_id = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(3))\n    self.chem_comp_chainId = [ c for c in string.ascii_uppercase if not (c in self.usedId)][0]\n    self.chem_comp_resSeq = 100\n    self.usedId[self.chem_comp_chainId] = []\n    return self.chem_comp_chainId, self.chem_comp_resSeq, self.chem_comp_id\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.new_chem_comp_atom","title":"<code>new_chem_comp_atom(obj, element)</code>","text":"<p>create and return unique atom name</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def new_chem_comp_atom(self, obj, element):\n    \"\"\" create and return unique atom name \"\"\"\n    if \"s_m_pdb_atom_name\" in obj:\n        atom_name = obj[\"s_m_pdb_atom_name\"].strip()\n    else:\n        atom_name = \"{}{}\".format(element,1)\n    if not (atom_name in self.usedId[self.chem_comp_chainId]):\n        self.usedId[self.chem_comp_chainId].append(atom_name)\n        return atom_name\n    else:\n        for i in range(1,10000):\n            new_name = \"{}{}\".format(element,i)\n            if not (new_name in self.usedId[self.chem_comp_chainId]):\n                self.usedId[self.chem_comp_chainId].append(new_name)\n                return new_name\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.setInDict","title":"<code>setInDict(dataDict, mapList, value)</code>  <code>staticmethod</code>","text":"Source code in <code>src/desmondtools/maestro.py</code> <pre><code>@staticmethod\ndef setInDict(dataDict, mapList, value):\n    if mapList:\n        Maestro.getFromDict(dataDict, mapList[:-1])[mapList[-1]] = value\n    else:\n        for k,v in value.items():\n            dataDict[k] = v\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.to_mmcif","title":"<code>to_mmcif()</code>","text":"Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def to_mmcif(self):\n    token = None\n    entity_id = 0\n    for line in self.contents:\n        line = line.strip()\n\n        if not line or line.startswith(\"#\"): \n            continue\n\n        # f_m_ct block\n        if line.startswith(\"f_m_ct {\"):\n            token = 'f_m_ct_key'\n            natoms = 0\n            nbonds = 0\n            entity_id += 1\n            k = []\n            continue\n        if token == 'f_m_ct_key':\n            if line.startswith(\":::\"): # end of f_m_ct key block\n                n = len(k)\n                token = 'f_m_ct_val'\n                v = []\n                continue\n            k.append(line)\n        if token == 'f_m_ct_val':\n            v.append(line)\n            if len(v) == n:\n                data = dict(zip(k,v))\n                if \"s_lp_Variant\" in data:\n                    self.title = data['s_lp_Variant'].replace('\"','').replace(\"'\",\"\")\n                else:\n                    self.title = data['s_m_title'].replace('\"','').replace(\"'\",\"\")\n                self.append_entry(self.title)\n                token = None\n\n\n        # m_atom block\n        if line.startswith(\"m_atom\") :\n            natoms = int(self.count.findall(line)[0])\n            token = 'm_atom_key'\n            k = ['i_atom_index'] # 1st column is atom_index\n            continue\n        if token == 'm_atom_key':\n            if line.startswith(\":::\"):\n                token = 'm_atom_val'\n                nv = 0\n                m_atom = {}\n                m_atom_resName = {}\n                continue\n            k.append(line)\n        if token == 'm_atom_val':\n            v = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n            data = dict(zip(k,v))\n\n            # build hierarchical structure of chain/ resSeq/ resName\n            chainId = self.value_or_default(data,\"s_m_chain_name\", \"A\")\n            resSeq = int(self.value_or_default(data, \"i_m_residue_number\", 1))\n            resName = self.value_or_default(data, \"s_m_pdb_residue_name\", \"?\")\n            if resName in self.std_rename:\n                resName = self.std_rename[resName]\n            if not chainId in m_atom:\n                m_atom[chainId] = {}\n            if not resSeq in m_atom[chainId]:\n                m_atom[chainId][resSeq] = {}\n            if not resName in m_atom[chainId][resSeq]:\n                m_atom[chainId][resSeq][resName] = []\n            m_atom[chainId][resSeq][resName].append(data)\n            m_atom_resName[int(data[\"i_atom_index\"])] = resName\n\n            nv += 1\n            if nv == natoms: # end of m_atom block\n                token = None\n\n        \"\"\" m_bond block \"\"\"\n        if line.startswith(\"m_bond\") :\n            nbonds = int(self.count.findall(line)[0])\n            token = 'm_bond_key'\n            k = ['i_bond_index']\n            continue\n        if token == 'm_bond_key':\n            if line.startswith(\":::\"): # end of m_bond key block\n                token = 'm_bond_val'\n                nv = 0\n                m_bond = {}\n                continue\n            k.append(line)\n        if token == 'm_bond_val':\n            v = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n            data = dict(zip(k,v))\n\n            # build bond connectivity\n            p = int(data[\"i_m_from\"]) \n            q = int(data[\"i_m_to\"]) \n            r = int(data[\"i_m_order\"])\n            if p in m_bond:\n                m_bond[p][q] = r\n            else:\n                m_bond[p] = {q:r}\n            if q in m_bond:\n                m_bond[q][p] = r\n            else:\n                m_bond[q] = {p:r}\n\n            nv += 1\n            if nv == nbonds: # m_bond block ends\n                token = None\n\n                # create mmcif _atom_site\n                for chainId_ in sorted(m_atom):\n                    for resSeq_ in sorted(m_atom[chainId_]):\n                        for resName_ in sorted(m_atom[chainId_][resSeq_]):\n                            if resName_ in self.std_residues:\n                                group_PDB = \"ATOM\"\n                                chainId, resSeq, resName = chainId_, resSeq_, resName_\n                            else:\n                                group_PDB = \"HETATM\"\n                                # check if new_chem_comp is necessary\n                                this_residue = [ int(d[\"i_atom_index\"]) for d in m_atom[chainId_][resSeq_][resName_] ]\n                                need_new_chem_comp = True\n                                for p_ in this_residue:\n                                    for q_, bond_order in m_bond[p_].items():\n                                        if  (not (q_ in this_residue)) and \\\n                                            (not (m_atom_resName[q_] in self.std_residues)) and \\\n                                            (q_ in self.iamap):\n                                            # do not create another chem_comp\n                                            need_new_chem_comp = False\n                                            q, chainId, resSeq, resName = self.iamap[q_]\n                                            break\n                                if need_new_chem_comp:\n                                    chainId, resSeq, resName = self.new_chem_comp()\n\n                            # go through all atoms within the same residue\n                            for d in m_atom[chainId_][resSeq_][resName_]:\n                                self.serial += 1\n                                self.iamap[int(d[\"i_atom_index\"])] = (self.serial, chainId, resSeq, resName)\n                                element = self.atomic_symbol[int(d[\"i_m_atomic_number\"])]\n                                if group_PDB == \"ATOM\":\n                                    name = self.value_or_default(d,\"s_m_pdb_atom_name\", \"?\")\n                                else:\n                                    name = self.new_chem_comp_atom(d, element) \n                                x = float(d[\"r_m_x_coord\"])\n                                y = float(d[\"r_m_y_coord\"])\n                                z = float(d[\"r_m_z_coord\"])\n                                occupancy = float(self.value_or_default(d,\"r_m_pdb_occupancy\",1))\n                                bfactor = float(self.value_or_default(d,\"r_m_pdb_tfactor\", 0))\n                                formal_charge = int(self.value_or_default(d,\"i_m_formal_charge\", 0))\n                                self.append_atom_site(\n                                    group_PDB = group_PDB, \n                                    id = self.serial,\n                                    type_symbol = element,\n                                    label_atom_id = name,\n                                    label_alt_id = \".\",\n                                    label_comp_id = resName,\n                                    label_asym_id = chainId,\n                                    label_entity_id = entity_id,\n                                    label_seq_id = resSeq,\n                                    pdbx_PDB_ins_code = \"?\",\n                                    Cartn_x = x,\n                                    Cartn_y = y,\n                                    Cartn_z = z,\n                                    occupancy = occupancy,\n                                    B_iso_or_equiv = bfactor,\n                                    pdbx_formal_charge = formal_charge,\n                                    auth_seq_id = resSeq,\n                                    auth_comp_id = resName,\n                                    auth_asym_id = chainId,\n                                    auth_atom_id = name,\n                                    pdbx_PDB_model_num = 1,\n                                )\n\n                # create mmcif _chem_comp_bond\n                for chainId_ in sorted(m_atom):\n                    for resSeq_ in sorted(m_atom[chainId_]):\n                        for resName_ in sorted(m_atom[chainId_][resSeq_]):\n                            if not (resName_ in self.std_residues): # HETATM\n                                for d in m_atom[chainId_][resSeq_][resName_]:\n                                    p_ = int(d[\"i_atom_index\"])\n                                    p, p_chainId, p_resSeq, p_resName = self.iamap[p_]\n                                    if p_ in m_bond:\n                                        for q_, bond_order in m_bond[p_].items():\n                                            q, q_chainId, q_resSeq, q_resName = self.iamap[q_]\n                                            self.append_chem_comp_bond(p_resName, p, q, bond_order)\n\n    cifo = CifFileWriter(\"{}.cif\".format(self.prefix))\n\n    # clean up undefined dictionary\n    # force to copy a list to avoid \n    # RuntimeError: dictionary changed size during iteration\n    for k in list(self.mmcif): \n        if not self.mmcif[k]:\n            del self.mmcif[k]\n\n    cifo.write({ \"desmondtools\" : self.mmcif })\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.to_pdb","title":"<code>to_pdb(first_entry_coord_only=True)</code>","text":"Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def to_pdb(self, first_entry_coord_only=True) -&gt; None:\n    content = self.to_pdb_contents(first_entry_coord_only)\n    with open(f\"{self.prefix}.pdb\", \"w\") as f:\n        for k, v in content.items():\n            for kk, vv in v.items():\n                if kk == \"pdb\":\n                    f.write(vv)\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.to_pdb_contents","title":"<code>to_pdb_contents(first_entry_coord_only=True)</code>","text":"Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def to_pdb_contents(self, first_entry_coord_only=True) -&gt; Dict:\n    count = re.compile(r'\\[(\\d+)\\]')\n    content = {}\n    entry_number = 0\n    q = None\n    for line in self.contents:\n        line = line.strip()\n        if not line or line.startswith(\"#\"): continue\n        # parse f_m_ct\n        if line.startswith(\"f_m_ct {\"):\n            q = 'f_m_ct_key'\n            entry_number += 1\n            natoms = 0\n            nbonds = 0\n            k = []\n            continue\n        if q == 'f_m_ct_key' and line.startswith(\":::\"):\n            n = len(k)\n            q = 'f_m_ct_val'\n            vm = []\n            va = []\n            vb = []\n            continue\n        if q == 'f_m_ct_key': k.append(line)\n        if q == 'f_m_ct_val':\n            vm.append(line)\n            if len(vm) == n:\n                data = dict(zip(k,vm))\n                q = None\n                title = data['s_m_title'].replace('\"','').replace(\"'\",\"\")\n                content[title] = data\n\n        if line.startswith(\"m_atom\") :\n            natoms = int(count.findall(line)[0])\n            q = 'm_atom_key'\n            k = ['atom_index']\n            continue\n        if q == 'm_atom_key' and line.startswith(\":::\"):\n            q = 'm_atom_val'\n            nv = 0\n            continue\n        if q == 'm_atom_key': k.append(line)\n        if q == 'm_atom_val':\n            c = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n            data = dict(zip(k,c))\n            nv += 1\n            va.append(data)\n            if nv == natoms:\n                q = None\n                if (first_entry_coord_only and entry_number == 1) or \\\n                    (not first_entry_coord_only):\n                    content[title]['pdb'] = \\\n                    Maestro.PDB_MODEL_FORMAT(entry_number) + \"\\n\" + \\\n                    self.PDB_ATOM_FORMAT(va)\n\n        if line.startswith(\"m_bond\") :\n            nbonds = int(count.findall(line)[0])\n            q = 'm_bond_key'\n            k = ['bond_index']\n            continue\n        if q == 'm_bond_key' and line.startswith(\":::\"):\n            q = 'm_bond_val'\n            nv = 0\n            continue\n        if q == 'm_bond_key': k.append(line)\n        if q == 'm_bond_val':\n            c = ['' if x==\"&lt;&gt;\" else x for x in shlex.split(line)]\n            data = dict(zip(k,c))\n            # conect information only for ligands\n            if not 'i_glide_grid_version' in content[title] :\n                vb.append(data)\n            nv += 1\n            if nv == nbonds:\n                q = None\n                if (first_entry_coord_only and entry_number == 1) or \\\n                    (not first_entry_coord_only):\n                    if vb:\n                        content[title]['pdb'] += Maestro.PDB_CONECT_FORMAT(vb)\n                    content[title]['pdb'] += 'ENDMDL\\nEND'\n    return content\n</code></pre>"},{"location":"index.html#desmondtools.Maestro.value_or_default","title":"<code>value_or_default(obj, k, default)</code>","text":"<p>return value or default</p> Source code in <code>src/desmondtools/maestro.py</code> <pre><code>def value_or_default(self, obj, k, default):\n    \"\"\" return value or default \"\"\"\n    v = None\n    if k in obj:\n        if type(obj[k]) == str:\n            v = obj[k].strip()\n    if v is None:\n        return default\n    else:\n        return v\n</code></pre>"}]}