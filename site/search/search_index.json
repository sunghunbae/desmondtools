{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>DesmondTools have a set of command-line scripts and a python library written to make setting up the molecular dynamics simulations easier for Desmond.</p>"},{"location":"index.html#install","title":"Install","text":"<pre><code>$ pip install desmondtools\n</code></pre>"},{"location":"index.html#usage","title":"Usage","text":"<p><code>desmondtools.Multisim</code> class helps to read and modify Schrodinger Desmond <code>.msj</code> and <code>.cfg</code> files which are often generated by Schrodinger Maestro GUI task panels. With a simple python script using <code>desmondtools</code>, you can easily prepare and setup multiple MD simulations without repeated launching of the Maestro or manual editting. Below example shows how to modify or create contents of the <code>.msj</code> and <code>.cfg</code> files through the <code>.dot</code> attribute of a <code>Multisim</code> instance.</p> <pre><code>from desmondtools import Multisim\n\n# read template .msj and .cfg\nmd_msj = Multisim(template=\"desmond-md.msj\")\nmd_cfg = Multisim(template=\"desmond-md.cfg\")\n\nwith open(msj_file,\"w\") as msj:\n    # modify desmond msj template\n    md_msj.dot.simulate[-1].cfg_file = cfg_file_basename\n\n    # Setting up restraints using the restraints keyword:\n    # https://www.schrodinger.com/kb/332119\n    if args.posres_force &gt; 0.0:\n        # print the restraints in the multisim log file\n        md_msj.dot.simulate[-1].print_restraint = 'true'\n\n        # add the new terms defined in \"restraints.new\" to existing restraints.\n        # The default is restraints.existing = ignore which will \n        # delete existing terms before adding any new ones.\n        # md_msj.dot.simulate[-1].restraints.existing = 'retain'\n\n        md_msj.dot.simulate[-1].restraints.new = [\n            {\n                'name'              : 'posre_harm',\n                'atoms'             : [ f'\"{args.posres}\"' ],\n                'force_constants'   : [ args.posres_force, ] * 3,\n            }\n            ]\n        # force constants in the x, y, and z direction\n\n    # writing modified msj\n    md_msj.write(msj)\n\nwith open(cfg_file,\"w\") as cfg:\n    # read and modify desmond cfg template\n    md_cfg.dot.randomize_velocity.seed = random.randint(1000, 9999)\n    md_cfg.dot.time = total_simulation_time\n    md_cfg.dot.temperature = t_schedule\n    md_cfg.dot.trajectory.interval = args.interval\n    # wring modified cfg\n    md_cfg.write(cfg)\n</code></pre>"},{"location":"index.html#example-of-a-msj-file-part","title":"Example of a <code>.msj</code> file (part)","text":"<pre><code>task {\n   task = \"desmond:auto\"\n   set_family = {\n      desmond = {\n         checkpt.write_last_step = no\n      }\n   }\n}\n\nsimulate {\n   title       = \"Brownian Dynamics NVT, T = 10 K, small timesteps, and restraints on solute heavy atoms, 100ps\"\n   annealing   = off\n   time        = 100\n   timestep    = [0.001 0.001 0.003 ]\n   temperature = 10.0\n   ensemble = {\n      class = \"NVT\"\n      method = \"Brownie\"\n      brownie = {\n         delta_max = 0.1\n      }\n   }\n   restrain = {\n      atom = \"solute_heavy_atom\"\n      force_constant = 50.0\n   }\n}\n\nsimulate {\n   effect_if   = [[\"==\" \"-gpu\" \"@*.*.jlaunch_opt[-1]\"] 'ensemble.method = Langevin']\n   title       = \"NVT, T = 10 K, small timesteps, and restraints on solute heavy atoms, 12ps\"\n   annealing   = off\n   time        = 12\n   timestep    = [0.001 0.001 0.003]\n   temperature = 10.0\n   restrain    = { atom = solute_heavy_atom force_constant = 50.0 }\n   ensemble    = {\n      class  = NVT\n      method = Berendsen\n      thermostat.tau = 0.1\n   }\n\n   randomize_velocity.interval = 1.0\n   eneseq.interval             = 0.3\n   trajectory.center           = []\n}\n</code></pre>"},{"location":"index.html#example-of-cfg-file-part","title":"Example of <code>.cfg</code> file (part)","text":"<pre><code>annealing = false\nbackend = {\n}\nbigger_rclone = false\ncheckpt = {\n   first = 0.0\n   interval = 200.0\n   name = \"$JOBNAME.cpt\"\n   write_last_step = true\n}\ncpu = 1\ncutoff_radius = 9.0\nelapsed_time = 0.0\nenergy_group = false\neneseq = {\n   first = 0.0\n   interval = 1.2\n   name = \"$JOBNAME$[_replica$REPLICA$].ene\"\n}\nensemble = {\n   barostat = {\n      tau = 2.0\n   }\n   class = NPT\n   method = MTK\n   thermostat = {\n      tau = 1.0\n   }\n}\n</code></pre>"},{"location":"index.html#cli","title":"CLI","text":"<p>Command-Line Interfaces are built on the <code>Multisim</code> class. Some CLIs require Schrodinger Python API.</p> Command-line interface Description <code>mdinfo</code> Check running MD simulations <code>batch-desmond-setup</code> Batch Prepare MD systems <code>batch-desmond-min</code> Batch Setup energy minimizations <code>batch-desmond-md</code> Batch Setup MD simulations <code>batch-desmond-metad</code> Batch Setup metadynamics <code>batch-desmond-report</code> Batch Generate reports <code>batch-desmond-pli</code> Batch Analyze protein-ligand interactions <code>batch-desmond-distance</code> Batch Analyze distance <code>batch-desmond-dihedral</code> Batch Analyze dihedral angles <code>batch-desmond-ligrmsd</code> Batch Analyze ligand rmsd <code>batch-desmond-rg</code> Batch Analyze radius of gyration <p>For more helps, <code>$ command --help</code>.</p>"},{"location":"index.html#metadynamics","title":"Metadynamics","text":""},{"location":"index.html#types-of-collective-variables","title":"Types of Collective Variables","text":"type Description Default Width Wall Floor Atom sites dist Distance 0.05 \u00c5 yes yes 2 angle Angle 2.5\u00b0 yes yes 3 dihedral Dihedral 5.0\u00b0 no no 4 rgyr Radius of gyration 0.1 \u00c5 no no 1 rgyr_mass Mass-weighted radius of gyration 0.1 \u00c5 no no 1 rmsd RMSD from aligned starting structure 0.1 \u00c5 no no 1 rmsd_symm Symmetry aware RMSD 0.1 \u00c5 no no 1 zdist Distance along the z axis 0.05 \u00c5 yes yes 1 zdist0 Absolute distance along the z axis 0.1 \u00c5 yes yes 1 whim1 WHIM1 - first principal moment [35] 0.5 \u00c52 no no 1 whim2 WHIM2 - second principal moment [35] 0.25 \u00c52 no no 1"},{"location":"index.html#examples-of-collective-variables","title":"Examples of Collective Variables","text":"<pre><code>distance:\n    cv = [\n        {atom = [\"res. UNK\" \"res. 849\" ]\n        type = dist\n        wall = 40\n        floor = 10\n        width = 0.05\n        }\n    ]\n\ndihedral:\n    cv = [\n        {atom = [404 406 407 415 ]\n        type = dihedral\n        width = 5.0\n        }\n        {atom = [406 407 415 417 ]\n        type = dihedral\n        width = 5.0\n        }\n    ]\n\nzdist(membrane):\n    cv = [\n        {atom = [\"res. UNK\"]\n        type = zdist\n        width = 0.05\n        wall = 20\n        floor = 5\n        }\n        ]\n\nrmsd:\n    cv = [\n        {atom = [\"res. UNK\" \"res. 849\" ]\n        type = rmsd\n        width = 0.1\n        }\n    ]\n</code></pre>"},{"location":"index.html#well-tempered-metadynamics","title":"Well-Tempered Metadynamics","text":"<p>In well-tempered metadynamics, the height of the deployed Gaussians are rescaled (decreased) during simulation time by: omega_0 * exp(-V/(kB * \u0394T)) Where omega_0 is the initial hill height, V is the bias potential and the denominator in the exponential, kB * \u0394T, is the bias factor (kTemp). During well-tempered metadynamics, the dynamics of the system are effectively accelerated  (without heating up the system) up to T + \u0394T, where T is the chosen MD simulation temperature.  The choice of the bias factor value is guided by the highest barrier in the simulation system  which the well-tempered metadynamics run should overcome. Here are some suggestions,  assuming that the initial hill height \u03c90 (height parameter in the Metadynamics panel) has been set to 0.3 kcal/mol:</p> Max. barrier height (kcal/mol) kTemp (kcal/mol) 3 1.7 6 3.4 10 5.6 15 8.4 20 11.2"},{"location":"index.html#extending-simulations","title":"Extending Simulations","text":"<p>See https://www.schrodinger.com/kb/788642 for extending metadynamics simulation.</p>"},{"location":"index.html#desmondtools.Multisim","title":"<code>desmondtools.Multisim</code>","text":"<p>Parsing Desmond multisim .cfg and .msj expressions</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>class Multisim:\n    \"\"\"Parsing Desmond multisim .cfg and .msj expressions\"\"\"\n    # variable, value, array, expr\n    # pyparsing module\u2019s default behavior is to ignore whitespace.\n    # +: AND, |: MatchFirst, left-to-right, ^: Or(longest match)\n    # Group: --&gt; list\n    # Dict: --&gt; dict\n    # Forward: --&gt; recursive\n\n    EQ = pp.Suppress('=')\n    LBRACKET, RBRACKET, LBRACE, RBRACE = map(pp.Literal, \"[]{}\")\n    variable = (pp.Word(pp.alphanums + \"._/?-@\") + \n                pp.Opt(\".\" + pp.Word(pp.alphanums))).set_parse_action(''.join)\n    _string1 = pp.Word(pp.alphanums + \"._/?-@*\")\n    _string2 = pp.quoted_string()\n    _number  = ppc.number()\n    value   = (_string1 | _string2 | _number)\n    array   = pp.Forward()\n    array   &lt;&lt;= pp.Group(LBRACKET + (pp.ZeroOrMore(value | array)) + RBRACKET)\n    expr    = pp.Forward()\n    _expr_0  = (variable + EQ + value)\n    _expr_1  = (variable + EQ + array)\n    _expr_2  = (variable + EQ + pp.Group(\n        LBRACE + pp.ZeroOrMore(expr) + RBRACE ))\n    _expr_3  = (variable + EQ + pp.Group(\n        LBRACKET + pp.ZeroOrMore(pp.Group(LBRACE + expr + RBRACE)) + RBRACKET))\n    _expr_4  = pp.Group(variable + pp.Group(\n        LBRACE + pp.ZeroOrMore( expr ) + RBRACE))\n    expr    &lt;&lt;= pp.OneOrMore(pp.Dict(pp.Group(\n        _expr_0 | _expr_1 | _expr_2 | _expr_3 | _expr_4)))\n    expr.ignore(\"#\" + pp.restOfLine)\n\n\n    def __init__(self, **kwargs):\n        self.template_path = None\n        self.ParseResults = None\n        self.dict = {}\n        self.dot = DotMap()\n        self.output = sys.stdout # do not attempt to close\n        self.indent = 4\n\n        if 'template' in kwargs:\n            template = kwargs['template']\n            template_path = pathlib.Path(template)\n            if template_path.is_file():\n                self.template_path = template_path\n            else:\n                with importlib.resources.files('desmondtools') as template_path:\n                    self.template_path = template_path / template\n            if self.template_path is None:\n                raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), template)\n\n            self.ParseResults = Multisim.expr.parse_file(self.template_path)\n            self.decode()\n\n        elif 'string' in kwargs:\n            string = kwargs['string']\n            try:\n                self.ParseResults = Multisim.expr.parse_string(string)\n                self.decode()\n            except:\n                raise RuntimeError(\"Multisim: cannot parse the input string.\")\n        else:\n            raise RuntimeError(\"Multisim: template filename or string is required.\")\n\n\n\n    @staticmethod\n    def unfold_dict_key(d) -&gt; None:\n        \"\"\"Unfold '.' in the keys of a dictionary\n\n        Args:\n            d (dict): dictionary (to be modified)\n        \"\"\"\n        ks = [ k for k in d ]\n        for k in ks:\n            v = d[k]\n            if '.' in k:\n                # d[k] = v --&gt; d[kk[0]] = { kk[1] : v }\n                _u = None\n                _k = k.split('.')[0]\n                for kk in k.split('.')[-1:0:-1]:\n                    if _u is None:\n                        _u = {kk : v }\n                    else:\n                        _u = {kk : _u}\n                d[_k] = _u\n                del d[k]\n            else:\n                pass\n            if isinstance(v, dict):\n                Multisim.unfold_dict_key(v)\n\n\n    @staticmethod\n    def traverse_dict(d) -&gt; None:\n        \"\"\"Recursively traverse a nested dictionary/list\n\n        Args:\n            d (dict): dictionary (to be modified)\n        \"\"\"\n        if isinstance(d, dict):\n            for k,v in d.items():\n                if isinstance(v, dict):\n                    Multisim.traverse_dict(v)            \n                elif isinstance(v, list):\n                    if v == ['{','}']:\n                        d[k] = {}\n                    elif v == ['[',']']:\n                        d[k] = []\n                    elif v[0] == '[' and v[-1] == ']':\n                        d[k] = v[1:-1]\n                        Multisim.traverse_dict(d[k])\n                    elif v[0] == '{' and v[-1] == '}':\n                        d[k] = dict(v[1:-1])\n                        Multisim.traverse_dict(d[k])\n        elif isinstance(d, list):\n            for k,v in enumerate(d):\n                if isinstance(v, dict):\n                    Multisim.traverse_dict(v)\n                elif isinstance(v, list):\n                    if v == ['{','}']:\n                        d[k] = {}\n                    elif v == ['[',']']:\n                        d[k] = []\n                    elif v[0] == '[' and v[-1] == ']':\n                        d[k] = v[1:-1]\n                        Multisim.traverse_dict(d[k])\n                    elif v[0] == '{' and v[-1] == '}':\n                        d[k] = dict(v[1:-1])\n                        Multisim.traverse_dict(d[k])\n\n\n    def decode(self) -&gt; None:\n        \"\"\"decode the parsed results into a dictionary and its dotmap\"\"\"\n        # create .dict\n        if isinstance(self.ParseResults.as_list()[0][0], str): # key\n            self.dict = self.ParseResults.as_dict()\n            Multisim.traverse_dict(self.dict)\n            # handle the case where key has '.'\n            Multisim.unfold_dict_key(self.dict)\n\n        elif isinstance(self.ParseResults.as_list()[0][0], list):\n            self.dict = [] # now self.dict is a list of dictionary\n            for section in self.ParseResults:\n                dict_ = dict(section.as_list())\n                Multisim.traverse_dict(dict_)\n                # handle the case where key has '.'\n                Multisim.unfold_dict_key(dict_)\n                self.dict.append(dict_)\n\n        # create .dot\n        if isinstance(self.dict, list):\n            self.dot = {}\n            for d in self.dict:\n                for k,v in d.items():\n                    if k in self.dot:\n                        if isinstance(self.dot[k], list):\n                            self.dot[k].append(v)\n                        else:\n                            self.dot[k] = [self.dot[k], v]\n                    else:\n                        self.dot[k] = v\n            self.dot = DotMap(self.dot)\n        else:\n            self.dot = DotMap(self.dict)\n\n\n\n    def write(self, output=None):\n        \"\"\"Writes DOT object\"\"\"\n        if isinstance(output, io.IOBase):\n            self.output = output\n        elif isinstance(output, str):\n            self.output = open(output, \"w\")\n\n        if isinstance(self.dict, list):\n            blocks = []\n            for k, v in self.dot.items():\n                if isinstance(v, list):\n                    for vv in v:\n                        blocks.append({k:vv})\n                else:\n                    blocks.append({k:v})\n            for block in blocks:\n                self._write_dict(block, block=True)\n                self.output.write(\"\\n\")\n        else:\n            self._write_dict(self.dot)\n\n\n    def _write_dict(self, d, block=False, depth=0):\n        \"\"\"subroutine of .write() method\"\"\"\n        spc = ' ' * self.indent * depth\n        if isinstance(d, dict) or isinstance(d, DotMap):\n            for k, v in d.items():\n                k = str(k)\n                if v:\n                    if isinstance(v, dict) or isinstance(v, DotMap):\n                        if depth == 0 and block:\n                            self.output.write(spc + k + \" {\\n\")\n                        else:\n                            self.output.write(spc + k + \" = {\\n\")\n                        self._write_dict(v, depth=depth+1)\n                        self.output.write(spc + \"}\\n\")\n                    elif isinstance(v, list):\n                        self.output.write(spc + k + \" = [\")\n                        for vv in v:\n                            if isinstance(vv, dict) or isinstance(vv, DotMap): \n                                self.output.write(\"{\\n\")\n                            elif isinstance(vv, list):\n                                self.output.write(\"[\")\n                            self._write_dict(vv, depth=depth+1)\n                            if isinstance(vv, dict) or isinstance(vv, DotMap):\n                                self.output.write(spc + \"}\")\n                            elif isinstance(vv, list):\n                                self.output.write(\"]\")                \n                        self.output.write(\"]\\n\")\n                    else:\n                        self.output.write(spc + k + \" = \" + str(v) +\"\\n\")\n                else:\n                    if isinstance(v, list) and (not bool(v)):\n                        self.output.write(spc + k + \" = []\\n\")\n                    elif (isinstance(v, dict) or isinstance(v, DotMap))and (not bool(v)):\n                        self.output.write(spc + k + \" = {\\n}\\n\")\n                    else:\n                        self.output.write(spc + k + \" =   \\n\")\n        elif isinstance(d, list):\n            for v in d:\n                self._write_dict(v, depth=depth+1)\n        else:\n            self.output.write(\" \" + str(d) + \" \")\n\n\n    def to_dot(self) -&gt; DotMap:\n        \"\"\"Returns parsed results as a DotMap object\n\n        Returns:\n            DotMap : DotMap object\n        \"\"\"\n        return self.dot\n\n\n    def to_list(self) -&gt; list:\n        \"\"\"Returns parsed results as a list\n\n        Returns:\n            list : list\n        \"\"\"\n        return self.ParseResults.as_list()\n\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Returns parsed results as a dictionary\n\n        Returns:\n            dict : dictionary\n        \"\"\"\n        return self.dict\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.EQ","title":"<code>EQ = pp.Suppress('=')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.ParseResults","title":"<code>ParseResults = Multisim.expr.parse_string(string)</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_0","title":"<code>_expr_0 = variable + EQ + value</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_1","title":"<code>_expr_1 = variable + EQ + array</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_2","title":"<code>_expr_2 = variable + EQ + pp.Group(LBRACE + pp.ZeroOrMore(expr) + RBRACE)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_3","title":"<code>_expr_3 = variable + EQ + pp.Group(LBRACKET + pp.ZeroOrMore(pp.Group(LBRACE + expr + RBRACE)) + RBRACKET)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_4","title":"<code>_expr_4 = pp.Group(variable + pp.Group(LBRACE + pp.ZeroOrMore(expr) + RBRACE))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._number","title":"<code>_number = ppc.number()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._string1","title":"<code>_string1 = pp.Word(pp.alphanums + '._/?-@*')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._string2","title":"<code>_string2 = pp.quoted_string()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.array","title":"<code>array = pp.Forward()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.dict","title":"<code>dict = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.dot","title":"<code>dot = DotMap()</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.expr","title":"<code>expr = pp.Forward()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.indent","title":"<code>indent = 4</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.output","title":"<code>output = sys.stdout</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.template_path","title":"<code>template_path = template_path / template</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.value","title":"<code>value = _string1 | _string2 | _number</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.variable","title":"<code>variable = pp.Word(pp.alphanums + '._/?-@') + pp.Opt('.' + pp.Word(pp.alphanums)).set_parse_action(''.join)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.__init__","title":"<code>__init__(**kwargs)</code>","text":"Source code in <code>desmondtools/multisim.py</code> <pre><code>def __init__(self, **kwargs):\n    self.template_path = None\n    self.ParseResults = None\n    self.dict = {}\n    self.dot = DotMap()\n    self.output = sys.stdout # do not attempt to close\n    self.indent = 4\n\n    if 'template' in kwargs:\n        template = kwargs['template']\n        template_path = pathlib.Path(template)\n        if template_path.is_file():\n            self.template_path = template_path\n        else:\n            with importlib.resources.files('desmondtools') as template_path:\n                self.template_path = template_path / template\n        if self.template_path is None:\n            raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), template)\n\n        self.ParseResults = Multisim.expr.parse_file(self.template_path)\n        self.decode()\n\n    elif 'string' in kwargs:\n        string = kwargs['string']\n        try:\n            self.ParseResults = Multisim.expr.parse_string(string)\n            self.decode()\n        except:\n            raise RuntimeError(\"Multisim: cannot parse the input string.\")\n    else:\n        raise RuntimeError(\"Multisim: template filename or string is required.\")\n</code></pre>"},{"location":"index.html#desmondtools.Multisim._write_dict","title":"<code>_write_dict(d, block=False, depth=0)</code>","text":"<p>subroutine of .write() method</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def _write_dict(self, d, block=False, depth=0):\n    \"\"\"subroutine of .write() method\"\"\"\n    spc = ' ' * self.indent * depth\n    if isinstance(d, dict) or isinstance(d, DotMap):\n        for k, v in d.items():\n            k = str(k)\n            if v:\n                if isinstance(v, dict) or isinstance(v, DotMap):\n                    if depth == 0 and block:\n                        self.output.write(spc + k + \" {\\n\")\n                    else:\n                        self.output.write(spc + k + \" = {\\n\")\n                    self._write_dict(v, depth=depth+1)\n                    self.output.write(spc + \"}\\n\")\n                elif isinstance(v, list):\n                    self.output.write(spc + k + \" = [\")\n                    for vv in v:\n                        if isinstance(vv, dict) or isinstance(vv, DotMap): \n                            self.output.write(\"{\\n\")\n                        elif isinstance(vv, list):\n                            self.output.write(\"[\")\n                        self._write_dict(vv, depth=depth+1)\n                        if isinstance(vv, dict) or isinstance(vv, DotMap):\n                            self.output.write(spc + \"}\")\n                        elif isinstance(vv, list):\n                            self.output.write(\"]\")                \n                    self.output.write(\"]\\n\")\n                else:\n                    self.output.write(spc + k + \" = \" + str(v) +\"\\n\")\n            else:\n                if isinstance(v, list) and (not bool(v)):\n                    self.output.write(spc + k + \" = []\\n\")\n                elif (isinstance(v, dict) or isinstance(v, DotMap))and (not bool(v)):\n                    self.output.write(spc + k + \" = {\\n}\\n\")\n                else:\n                    self.output.write(spc + k + \" =   \\n\")\n    elif isinstance(d, list):\n        for v in d:\n            self._write_dict(v, depth=depth+1)\n    else:\n        self.output.write(\" \" + str(d) + \" \")\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.decode","title":"<code>decode()</code>","text":"<p>decode the parsed results into a dictionary and its dotmap</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def decode(self) -&gt; None:\n    \"\"\"decode the parsed results into a dictionary and its dotmap\"\"\"\n    # create .dict\n    if isinstance(self.ParseResults.as_list()[0][0], str): # key\n        self.dict = self.ParseResults.as_dict()\n        Multisim.traverse_dict(self.dict)\n        # handle the case where key has '.'\n        Multisim.unfold_dict_key(self.dict)\n\n    elif isinstance(self.ParseResults.as_list()[0][0], list):\n        self.dict = [] # now self.dict is a list of dictionary\n        for section in self.ParseResults:\n            dict_ = dict(section.as_list())\n            Multisim.traverse_dict(dict_)\n            # handle the case where key has '.'\n            Multisim.unfold_dict_key(dict_)\n            self.dict.append(dict_)\n\n    # create .dot\n    if isinstance(self.dict, list):\n        self.dot = {}\n        for d in self.dict:\n            for k,v in d.items():\n                if k in self.dot:\n                    if isinstance(self.dot[k], list):\n                        self.dot[k].append(v)\n                    else:\n                        self.dot[k] = [self.dot[k], v]\n                else:\n                    self.dot[k] = v\n        self.dot = DotMap(self.dot)\n    else:\n        self.dot = DotMap(self.dict)\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns parsed results as a dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Returns parsed results as a dictionary\n\n    Returns:\n        dict : dictionary\n    \"\"\"\n    return self.dict\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_dot","title":"<code>to_dot()</code>","text":"<p>Returns parsed results as a DotMap object</p> <p>Returns:</p> Name Type Description <code>DotMap</code> <code>DotMap</code> <p>DotMap object</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def to_dot(self) -&gt; DotMap:\n    \"\"\"Returns parsed results as a DotMap object\n\n    Returns:\n        DotMap : DotMap object\n    \"\"\"\n    return self.dot\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_list","title":"<code>to_list()</code>","text":"<p>Returns parsed results as a list</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def to_list(self) -&gt; list:\n    \"\"\"Returns parsed results as a list\n\n    Returns:\n        list : list\n    \"\"\"\n    return self.ParseResults.as_list()\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.traverse_dict","title":"<code>traverse_dict(d)</code>  <code>staticmethod</code>","text":"<p>Recursively traverse a nested dictionary/list</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>dictionary (to be modified)</p> required Source code in <code>desmondtools/multisim.py</code> <pre><code>@staticmethod\ndef traverse_dict(d) -&gt; None:\n    \"\"\"Recursively traverse a nested dictionary/list\n\n    Args:\n        d (dict): dictionary (to be modified)\n    \"\"\"\n    if isinstance(d, dict):\n        for k,v in d.items():\n            if isinstance(v, dict):\n                Multisim.traverse_dict(v)            \n            elif isinstance(v, list):\n                if v == ['{','}']:\n                    d[k] = {}\n                elif v == ['[',']']:\n                    d[k] = []\n                elif v[0] == '[' and v[-1] == ']':\n                    d[k] = v[1:-1]\n                    Multisim.traverse_dict(d[k])\n                elif v[0] == '{' and v[-1] == '}':\n                    d[k] = dict(v[1:-1])\n                    Multisim.traverse_dict(d[k])\n    elif isinstance(d, list):\n        for k,v in enumerate(d):\n            if isinstance(v, dict):\n                Multisim.traverse_dict(v)\n            elif isinstance(v, list):\n                if v == ['{','}']:\n                    d[k] = {}\n                elif v == ['[',']']:\n                    d[k] = []\n                elif v[0] == '[' and v[-1] == ']':\n                    d[k] = v[1:-1]\n                    Multisim.traverse_dict(d[k])\n                elif v[0] == '{' and v[-1] == '}':\n                    d[k] = dict(v[1:-1])\n                    Multisim.traverse_dict(d[k])\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.unfold_dict_key","title":"<code>unfold_dict_key(d)</code>  <code>staticmethod</code>","text":"<p>Unfold '.' in the keys of a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>dictionary (to be modified)</p> required Source code in <code>desmondtools/multisim.py</code> <pre><code>@staticmethod\ndef unfold_dict_key(d) -&gt; None:\n    \"\"\"Unfold '.' in the keys of a dictionary\n\n    Args:\n        d (dict): dictionary (to be modified)\n    \"\"\"\n    ks = [ k for k in d ]\n    for k in ks:\n        v = d[k]\n        if '.' in k:\n            # d[k] = v --&gt; d[kk[0]] = { kk[1] : v }\n            _u = None\n            _k = k.split('.')[0]\n            for kk in k.split('.')[-1:0:-1]:\n                if _u is None:\n                    _u = {kk : v }\n                else:\n                    _u = {kk : _u}\n            d[_k] = _u\n            del d[k]\n        else:\n            pass\n        if isinstance(v, dict):\n            Multisim.unfold_dict_key(v)\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.write","title":"<code>write(output=None)</code>","text":"<p>Writes DOT object</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def write(self, output=None):\n    \"\"\"Writes DOT object\"\"\"\n    if isinstance(output, io.IOBase):\n        self.output = output\n    elif isinstance(output, str):\n        self.output = open(output, \"w\")\n\n    if isinstance(self.dict, list):\n        blocks = []\n        for k, v in self.dot.items():\n            if isinstance(v, list):\n                for vv in v:\n                    blocks.append({k:vv})\n            else:\n                blocks.append({k:v})\n        for block in blocks:\n            self._write_dict(block, block=True)\n            self.output.write(\"\\n\")\n    else:\n        self._write_dict(self.dot)\n</code></pre>"}]}