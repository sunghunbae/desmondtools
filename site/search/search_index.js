var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>DesmondTools have a set of command-line scripts and a python library written to make setting up the molecular dynamics simulations easier for Desmond.</p>"},{"location":"index.html#install","title":"Install","text":"<pre><code>$ pip install desmondtools\n</code></pre>"},{"location":"index.html#what-is-multisim-class","title":"What is Multisim Class?","text":"<p>The following code examples from <code>test/test_multisim.py</code> demonstrate the functionality of the Multisim class.</p> <pre><code>from desmondtools import Multisim\n\ndef test_Multisim_variable():\n    # parse_string returns ['barostat.tau']\n    o1 = Multisim.variable.parse_string(\"barostat.tau\")[0]\n    o2 = Multisim.variable.parse_string(\"barostat  .tau\")[0]\n    assert o1 == o2\n\n\ndef test_Multisim_expression_1():\n    i = \"task {} simulate { meta = [{a=1 b=3 c=[7 8 9]}] f = {} } simulate {n=2} simulate {n = 3}\"\n    D = Multisim(string=i).to_dot()\n    assert D.simulate[0].meta[0].b == str(3)\n    assert D.simulate[0].meta[0].c[1] == str(8)\n    assert D.simulate[-1].n == str(3)\n\n\ndef test_Multisim_expression_2():\n    i = \"simulate { effect_if = [[ a ] b ] }\"\n    D = Multisim(string=i).to_dot()\n    assert D.simulate.effect_if[0] == ['a']\n    assert D.simulate.effect_if[1] == 'b'\n\n\ndef test_Multisim_expression_3():\n    i = \"\"\"ensemble = {\n        brownie = {\n            delta_max = 0.1\n        }\n        class = NVT\n        method = Brownie\n        thermostat = {\n            tau = 1.0\n        }\n    }\"\"\"\n    D = Multisim(string=i)\n    assert D.dot.ensemble.brownie.delta_max == str(0.1)\n\n    # assert D.dot.ensemble.class == 'NVT'\n    #                       ^^^^^\n    # SyntaxError: invalid syntax\n    # 'class' is reserved word in python and raises SyntaxError\n    # use instead .['class']\n    assert D.dot.ensemble['class'] == 'NVT' # &lt;--- it does not raise SyntaxError\n\n    assert D.dot.ensemble.method == 'Brownie'\n    assert D.dot.ensemble.thermostat.tau == str(1.0)\n    D.write()\n\n\ndef test_Multisim_expression_4():\n    i = \"\"\"task {\n        task = \"desmond:auto\"\n    }\n    simulate {\n        title = \"NPT and no restraints, 24ps\"\n        effect_if = [[ \"@*.*.annealing\" ] 'annealing = off temperature = \"@*.*.temperature[0][0]\"' ]\n        time = 24\n        ensemble = {\n            class = NPT\n            method = Langevin\n            thermostat.tau = 0.1\n            barostat.tau = 2.0\n        }\n        eneseq.interval = 0.3\n        trajectory.center = solute\n    }\n    simulate {\n        meta = {\n            cv = [\n                { \n                    atom = [0 0 0 0] \n                    type = dihedral \n                    wall = 0  \n                    width = 5.0 \n                }\n            ]\n            cv_name = \"$JOBNAME$[_replica$REPLICA$].cvseq\"\n            first = 0.0\n            height = 0.03\n            interval = 0.09\n            name = \"$JOBNAME$[_replica$REPLICA$].kerseq\"\n        }\n    }\n    \"\"\"\n\n    D = Multisim(string=i)\n\n    assert len(D.dot.simulate[0].effect_if) == 2\n    assert len(D.dot.simulate[0].effect_if[0]) == 1\n    assert D.dot.simulate[0].ensemble.method == 'Langevin'\n    assert D.dot.simulate[0].ensemble.barostat.tau == str(2.0)\n    assert D.dot.simulate[0].eneseq.interval == str(0.3)\n    assert D.dot.simulate[0].trajectory.center == 'solute' # &lt;---\n\n    assert len(D.dot.simulate[1].meta.cv) == 1\n    assert len(D.dot.simulate[1].meta.cv[0].atom) == 4\n    assert D.dot.simulate[1].meta.height == str(0.03)\n    assert D.dot.simulate[-1].meta.cv[0].wall == str(0)\n\n    D.dot.simulate[0].ensemble.barostat.tau = 2.1\n    assert D.dot.simulate[0].ensemble.barostat.tau == 2.1\n\n    D.dot.simulate[1].meta.height = 0.06\n    assert D.dot.simulate[1].meta.height == 0.06\n\n    D.dot.simulate[-1].meta.cv[0].wall = 50.0\n    assert D.dot.simulate[-1].meta.cv[0].wall == 50.0\n\n\ndef test_Multisim_expression_5():\n    D= Multisim(template=\"desmond-md.msj\")\n    D.write()\n</code></pre>"},{"location":"index.html#caution","title":"Caution","text":"<p>Some keywords in the <code>.msj</code> or <code>.cfg</code> files may conflict with the reserved python syntax. In the below example, accessing the <code>class</code> variable by directly using the <code>.dot</code> expression such as <code>D.dot.ensemble.class = 'NVT'</code> would raise a <code>SyntaxError</code> because <code>class</code> is a reserved word in Python. However, you can avoid the error by using a dictionary type access such as <code>D.dot.ensemble['class'] = 'NVT'</code>.</p> <pre><code>    ensemble = {\n        brownie = {\n            delta_max = 0.1\n        }\n        class = NVT\n        method = Brownie\n        thermostat = {\n            tau = 1.0\n        }\n    }\n</code></pre>"},{"location":"index.html#use-of-multisim-class","title":"Use of Multisim Class","text":"<p>The <code>desmondtools.Multisim</code> class facilitates reading and modifying Schrodinger Desmond <code>.msj</code> and <code>.cfg</code> files, which are typically generated by Schrodinger Maestro GUI task panels. By using a simple Python script with <code>desmondtools</code>, you can efficiently prepare and set up multiple MD simulations without repeatedly launching Maestro or manually editing files. The example below demonstrates how to modify or create the contents of <code>.msj</code> and <code>.cfg</code> files using the <code>.dot</code> attribute of a <code>Multisim</code> instance.</p> <pre><code>from desmondtools import Multisim\n\n# read template .msj and .cfg\nmd_msj = Multisim(template=\"desmond-md.msj\")\nmd_cfg = Multisim(template=\"desmond-md.cfg\")\n\nwith open(msj_file,\"w\") as msj:\n    # modify desmond msj template\n    md_msj.dot.simulate[-1].cfg_file = cfg_file_basename\n\n    # Setting up restraints using the restraints keyword:\n    # https://www.schrodinger.com/kb/332119\n    if args.posres_force &gt; 0.0:\n        # print the restraints in the multisim log file\n        md_msj.dot.simulate[-1].print_restraint = 'true'\n\n        # add the new terms defined in \"restraints.new\" to existing restraints.\n        # The default is restraints.existing = ignore which will \n        # delete existing terms before adding any new ones.\n        # md_msj.dot.simulate[-1].restraints.existing = 'retain'\n\n        md_msj.dot.simulate[-1].restraints.new = [\n            {\n                'name'              : 'posre_harm',\n                'atoms'             : [ f'\"{args.posres}\"' ],\n                'force_constants'   : [ args.posres_force, ] * 3,\n            }\n            ]\n        # force constants in the x, y, and z direction\n\n    # writing modified msj\n    md_msj.write(msj)\n\nwith open(cfg_file,\"w\") as cfg:\n    # read and modify desmond cfg template\n    md_cfg.dot.randomize_velocity.seed = random.randint(1000, 9999)\n    md_cfg.dot.time = total_simulation_time\n    md_cfg.dot.temperature = t_schedule\n    md_cfg.dot.trajectory.interval = args.interval\n    # wring modified cfg\n    md_cfg.write(cfg)\n</code></pre> <p>Below are examples of <code>.msj</code> and <code>.cfg</code> files:</p> <pre><code># .msj file example (part)\n\ntask {\n   task = \"desmond:auto\"\n   set_family = {\n      desmond = {\n         checkpt.write_last_step = no\n      }\n   }\n}\n\nsimulate {\n   title       = \"Brownian Dynamics NVT, T = 10 K, small timesteps, ...\"\n   annealing   = off\n   time        = 100\n   timestep    = [0.001 0.001 0.003 ]\n   temperature = 10.0\n   ensemble = {\n      class = \"NVT\"\n      method = \"Brownie\"\n      brownie = {\n         delta_max = 0.1\n      }\n   }\n   restrain = {\n      atom = \"solute_heavy_atom\"\n      force_constant = 50.0\n   }\n}\n\nsimulate {\n   effect_if   = [[\"==\" \"-gpu\" \"@*.*.jlaunch_opt[-1]\"] 'ensemble.method = Langevin']\n   title       = \"NVT, T = 10 K, small timesteps, ...\"\n   annealing   = off\n   time        = 12\n   timestep    = [0.001 0.001 0.003]\n   temperature = 10.0\n   restrain    = { atom = solute_heavy_atom force_constant = 50.0 }\n   ensemble    = {\n      class  = NVT\n      method = Berendsen\n      thermostat.tau = 0.1\n   }\n\n   randomize_velocity.interval = 1.0\n   eneseq.interval             = 0.3\n   trajectory.center           = []\n}\n</code></pre> <pre><code># .cfg file example (part)\n\nrandomize_velocity = {\n   first = 0.0\n   interval = inf\n   seed = 2967\n   temperature = \"@*.temperature\"\n}\nrestrain = none\nsimbox = {\n   first = 0.0\n   interval = 1.2\n   name = \"$JOBNAME$[_replica$REPLICA$]_simbox.dat\"\n}\nsurface_tension = 0.0\ntaper = false\ntemperature = [\n   [300.0 0 ]\n]\ntime = 100000.0\ntimestep = [0.002 0.002 0.006 ]\n</code></pre>"},{"location":"index.html#event-and-interaction-classes","title":"Event and Interaction Classes","text":"<p>Schrodinger event analysis format or <code>.eaf</code> files use the same syntax as the <code>.cfg</code> or <code>.msj</code> files. So, the <code>desmondtools.Multisim</code> class is reused in the <code>desmondtools.Event</code> and <code>desmondtools.Interaction</code> classes to process Schrodinger provided trajectory analysis output <code>...-out.eaf</code> files. For example, below codes from <code>desmondtools.Interaction</code> class shows how the class uses the <code>.dot</code> attributes to process <code>.eaf</code> output files.</p> <pre><code>for section in self.dot.Keywords:\n    try:\n        assert section.ProtLigInter.HBondResult\n        self.num_frames = len(section.ProtLigInter.HBondResult)\n        for frame in section.ProtLigInter.HBondResult:\n            # [[3 \"_:ARG_143:HH22\" d-s \"L-FRAG_0:N6\" ]]\n            for (frameno, prot, hbond_type, lig) in frame:\n                prot = prot.strip('\\\"')\n                (_, resid, atom) = prot.split(\":\")\n                (resName, resSeq) = resid.split(\"_\")\n                resSeq = int(resSeq)\n                if resSeq in self.HBond:\n                    self.HBond[resSeq]['count'] += 1\n                else:\n                    self.HBond[resSeq] = {'resName': resName, 'count':1 }\n        for resSeq in sorted(self.HBond):\n            fraction = float(self.HBond[resSeq]['count'])/self.num_frames\n            if verbose:\n                print(f\"HBond {self.HBond[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n    except:\n        pass\n</code></pre>"},{"location":"index.html#command-line-interface","title":"Command-Line Interface","text":"<p>Command-Line Interfaces (CLI) are built on the <code>Multisim</code> class. Some CLIs require Schrodinger Python API.</p> Command-line interface Description batch-desmond-mdinfo Check running MD simulations batch-desmond-maeinfo Show info of .mae/.maegz file(s) batch-desmond-cmsinfo Show info of .cms file(s) batch-desmond-setup Batch Prepare MD systems batch-desmond-min Batch Setup energy minimizations batch-desmond-md Batch Setup MD simulations batch-desmond-metad Batch Setup metadynamics batch-desmond-report Batch Generate reports batch-desmond-pli Batch Analyze protein-ligand interactions batch-desmond-distance Batch Analyze distance batch-desmond-dihedral Batch Analyze dihedral angles batch-desmond-ligrmsd Batch Analyze ligand rmsd batch-desmond-rg Batch Analyze radius of gyration batch-desmond-rmsx Batch Analyze RMSD and ligand RMSF batch-desmond-mmgbsa Batch Analyze trajectory MMGBSA <p>For more helps, <code>$ command --help</code>.</p>"},{"location":"index.html#metadynamics","title":"Metadynamics","text":""},{"location":"index.html#types-of-collective-variables","title":"Types of Collective Variables","text":"type Description Default Width Wall Floor Atom sites dist Distance 0.05 \u00c5 yes yes 2 angle Angle 2.5\u00b0 yes yes 3 dihedral Dihedral 5.0\u00b0 no no 4 rgyr Radius of gyration 0.1 \u00c5 no no 1 rgyr_mass Mass-weighted radius of gyration 0.1 \u00c5 no no 1 rmsd RMSD from aligned starting structure 0.1 \u00c5 no no 1 rmsd_symm Symmetry aware RMSD 0.1 \u00c5 no no 1 zdist Distance along the z axis 0.05 \u00c5 yes yes 1 zdist0 Absolute distance along the z axis 0.1 \u00c5 yes yes 1 whim1 WHIM1 - first principal moment [35] 0.5 \u00c52 no no 1 whim2 WHIM2 - second principal moment [35] 0.25 \u00c52 no no 1"},{"location":"index.html#examples-of-collective-variables","title":"Examples of Collective Variables","text":"<pre><code>distance:\n    cv = [\n        {atom = [\"res. UNK\" \"res. 849\" ]\n        type = dist\n        wall = 40\n        floor = 10\n        width = 0.05\n        }\n    ]\n\ndihedral:\n    cv = [\n        {atom = [404 406 407 415 ]\n        type = dihedral\n        width = 5.0\n        }\n        {atom = [406 407 415 417 ]\n        type = dihedral\n        width = 5.0\n        }\n    ]\n\nzdist(membrane):\n    cv = [\n        {atom = [\"res. UNK\"]\n        type = zdist\n        width = 0.05\n        wall = 20\n        floor = 5\n        }\n        ]\n\nrmsd:\n    cv = [\n        {atom = [\"res. UNK\" \"res. 849\" ]\n        type = rmsd\n        width = 0.1\n        }\n    ]\n</code></pre>"},{"location":"index.html#well-tempered-metadynamics","title":"Well-Tempered Metadynamics","text":"<p>In well-tempered metadynamics, the height of the deployed Gaussians are rescaled (decreased) during simulation time by: omega_0 * exp(-V/(kB * \u0394T)) Where omega_0 is the initial hill height, V is the bias potential and the denominator in the exponential, kB * \u0394T, is the bias factor (kTemp). During well-tempered metadynamics, the dynamics of the system are effectively accelerated  (without heating up the system) up to T + \u0394T, where T is the chosen MD simulation temperature.  The choice of the bias factor value is guided by the highest barrier in the simulation system  which the well-tempered metadynamics run should overcome. Here are some suggestions,  assuming that the initial hill height \u03c90 (height parameter in the Metadynamics panel) has been set to 0.3 kcal/mol:</p> Max. barrier height (kcal/mol) kTemp (kcal/mol) 3 1.7 6 3.4 10 5.6 15 8.4 20 11.2"},{"location":"index.html#extending-simulations","title":"Extending Simulations","text":"<p>See https://www.schrodinger.com/kb/788642 for extending metadynamics simulation.</p>"},{"location":"index.html#desmondtools.Multisim","title":"<code>desmondtools.Multisim</code>","text":"<p>Parsing Desmond multisim .cfg and .msj expressions</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>class Multisim:\n    \"\"\"Parsing Desmond multisim .cfg and .msj expressions\"\"\"\n    # variable, value, array, expr\n    # pyparsing module\u2019s default behavior is to ignore whitespace.\n    # +: AND, |: MatchFirst, left-to-right, ^: Or(longest match)\n    # Group: --&gt; list\n    # Dict: --&gt; dict\n    # Forward: --&gt; recursive\n\n    EQ = pp.Suppress('=')\n    LBRACKET, RBRACKET, LBRACE, RBRACE = map(pp.Literal, \"[]{}\")\n    variable = (pp.Word(pp.alphanums + \"._/?-@\") + \n                pp.Opt(\".\" + pp.Word(pp.alphanums))).set_parse_action(''.join)\n    _string1 = pp.Word(pp.alphanums + \"._/?-@*\")\n    _string2 = pp.quoted_string()\n    _number  = ppc.number()\n    value   = (_string1 | _string2 | _number)\n    array   = pp.Forward()\n    array   &lt;&lt;= pp.Group(LBRACKET + (pp.ZeroOrMore(value | array)) + RBRACKET)\n    expr    = pp.Forward()\n    _expr_0  = (variable + EQ + value)\n    _expr_1  = (variable + EQ + array)\n    _expr_2  = (variable + EQ + pp.Group(\n        LBRACE + pp.ZeroOrMore(expr) + RBRACE ))\n    _expr_3  = (variable + EQ + pp.Group(\n        LBRACKET + pp.ZeroOrMore(pp.Group(LBRACE + expr + RBRACE)) + RBRACKET))\n    _expr_4  = pp.Group(variable + pp.Group(\n        LBRACE + pp.ZeroOrMore( expr ) + RBRACE))\n    expr    &lt;&lt;= pp.OneOrMore(pp.Dict(pp.Group(\n        _expr_0 | _expr_1 | _expr_2 | _expr_3 | _expr_4)))\n    expr.ignore(\"#\" + pp.restOfLine)\n\n\n    def __init__(self, **kwargs):\n        self.template_path = None\n        self.ParseResults = None\n        self.dict = {}\n        self.dot = DotMap()\n        self.output = sys.stdout # do not attempt to close\n        self.indent = 4\n\n        if 'template' in kwargs:\n            template = kwargs['template']\n            template_path = pathlib.Path(template)\n            if template_path.is_file():\n                self.template_path = template_path\n            else:\n                template_path = importlib.resources.files('desmondtools')\n                self.template_path = template_path / template\n            if self.template_path is None:\n                raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), template)\n\n            self.ParseResults = Multisim.expr.parse_file(self.template_path)\n            self.decode()\n\n        elif 'string' in kwargs:\n            string = kwargs['string']\n            try:\n                self.ParseResults = Multisim.expr.parse_string(string)\n                self.decode()\n            except:\n                raise RuntimeError(\"Multisim: cannot parse the input string.\")\n        else:\n            raise RuntimeError(\"Multisim: template filename or string is required.\")\n\n\n\n    @staticmethod\n    def unfold_dict_key(d) -&gt; None:\n        \"\"\"Unfold '.' in the keys of a dictionary\n\n        Args:\n            d (dict): dictionary (to be modified)\n        \"\"\"\n        ks = [ k for k in d ]\n        for k in ks:\n            v = d[k]\n            if '.' in k:\n                # d[k] = v --&gt; d[kk[0]] = { kk[1] : v }\n                _u = None\n                _k = k.split('.')[0]\n                for kk in k.split('.')[-1:0:-1]:\n                    if _u is None:\n                        _u = {kk : v }\n                    else:\n                        _u = {kk : _u}\n                d[_k] = _u\n                del d[k]\n            else:\n                pass\n            if isinstance(v, dict):\n                Multisim.unfold_dict_key(v)\n\n\n    @staticmethod\n    def traverse_dict(d) -&gt; None:\n        \"\"\"Recursively traverse a nested dictionary/list\n\n        Args:\n            d (dict): dictionary (to be modified)\n        \"\"\"\n        if isinstance(d, dict):\n            for k,v in d.items():\n                if isinstance(v, dict):\n                    Multisim.traverse_dict(v)            \n                elif isinstance(v, list):\n                    if v == ['{','}']:\n                        d[k] = {}\n                    elif v == ['[',']']:\n                        d[k] = []\n                    elif v[0] == '[' and v[-1] == ']':\n                        d[k] = v[1:-1]\n                        Multisim.traverse_dict(d[k])\n                    elif v[0] == '{' and v[-1] == '}':\n                        d[k] = dict(v[1:-1])\n                        Multisim.traverse_dict(d[k])\n        elif isinstance(d, list):\n            for k,v in enumerate(d):\n                if isinstance(v, dict):\n                    Multisim.traverse_dict(v)\n                elif isinstance(v, list):\n                    if v == ['{','}']:\n                        d[k] = {}\n                    elif v == ['[',']']:\n                        d[k] = []\n                    elif v[0] == '[' and v[-1] == ']':\n                        d[k] = v[1:-1]\n                        Multisim.traverse_dict(d[k])\n                    elif v[0] == '{' and v[-1] == '}':\n                        d[k] = dict(v[1:-1])\n                        Multisim.traverse_dict(d[k])\n\n\n    def decode(self) -&gt; None:\n        \"\"\"decode the parsed results into a dictionary and its dotmap\"\"\"\n        # create .dict\n        if isinstance(self.ParseResults.as_list()[0][0], str): # key\n            self.dict = self.ParseResults.as_dict()\n            Multisim.traverse_dict(self.dict)\n            # handle the case where key has '.'\n            Multisim.unfold_dict_key(self.dict)\n\n        elif isinstance(self.ParseResults.as_list()[0][0], list):\n            self.dict = [] # now self.dict is a list of dictionary\n            for section in self.ParseResults:\n                dict_ = dict(section.as_list())\n                Multisim.traverse_dict(dict_)\n                # handle the case where key has '.'\n                Multisim.unfold_dict_key(dict_)\n                self.dict.append(dict_)\n\n        # create .dot\n        if isinstance(self.dict, list):\n            self.dot = {}\n            for d in self.dict:\n                for k,v in d.items():\n                    if k in self.dot:\n                        if isinstance(self.dot[k], list):\n                            self.dot[k].append(v)\n                        else:\n                            self.dot[k] = [self.dot[k], v]\n                    else:\n                        self.dot[k] = v\n            self.dot = DotMap(self.dot)\n        else:\n            self.dot = DotMap(self.dict)\n\n\n\n    def write(self, output=None):\n        \"\"\"Writes DOT object\"\"\"\n        if isinstance(output, io.IOBase):\n            self.output = output\n        elif isinstance(output, str):\n            self.output = open(output, \"w\")\n\n        if isinstance(self.dict, list):\n            blocks = []\n            for k, v in self.dot.items():\n                if isinstance(v, list):\n                    for vv in v:\n                        blocks.append({k:vv})\n                else:\n                    blocks.append({k:v})\n            for block in blocks:\n                self._write_dict(block, block=True)\n                self.output.write(\"\\n\")\n        else:\n            self._write_dict(self.dot)\n\n\n    def _write_dict(self, d, block=False, depth=0):\n        \"\"\"subroutine of .write() method\"\"\"\n        spc = ' ' * self.indent * depth\n        if isinstance(d, dict) or isinstance(d, DotMap):\n            for k, v in d.items():\n                k = str(k)\n                if v:\n                    if isinstance(v, dict) or isinstance(v, DotMap):\n                        if depth == 0 and block:\n                            self.output.write(spc + k + \" {\\n\")\n                        else:\n                            self.output.write(spc + k + \" = {\\n\")\n                        self._write_dict(v, depth=depth+1)\n                        self.output.write(spc + \"}\\n\")\n                    elif isinstance(v, list):\n                        self.output.write(spc + k + \" = [\")\n                        for vv in v:\n                            if isinstance(vv, dict) or isinstance(vv, DotMap): \n                                self.output.write(\"{\\n\")\n                            elif isinstance(vv, list):\n                                self.output.write(\"[\")\n                            self._write_dict(vv, depth=depth+1)\n                            if isinstance(vv, dict) or isinstance(vv, DotMap):\n                                self.output.write(spc + \"}\")\n                            elif isinstance(vv, list):\n                                self.output.write(\"]\")                \n                        self.output.write(\"]\\n\")\n                    else:\n                        self.output.write(spc + k + \" = \" + str(v) +\"\\n\")\n                else:\n                    if isinstance(v, list) and (not bool(v)):\n                        self.output.write(spc + k + \" = []\\n\")\n                    elif (isinstance(v, dict) or isinstance(v, DotMap))and (not bool(v)):\n                        self.output.write(spc + k + \" = {\\n}\\n\")\n                    else:\n                        self.output.write(spc + k + \" =   \\n\")\n        elif isinstance(d, list):\n            for v in d:\n                self._write_dict(v, depth=depth+1)\n        else:\n            self.output.write(\" \" + str(d) + \" \")\n\n\n    def to_dot(self) -&gt; DotMap:\n        \"\"\"Returns parsed results as a DotMap object\n\n        Returns:\n            DotMap : DotMap object\n        \"\"\"\n        return self.dot\n\n\n    def to_list(self) -&gt; list:\n        \"\"\"Returns parsed results as a list\n\n        Returns:\n            list : list\n        \"\"\"\n        return self.ParseResults.as_list()\n\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Returns parsed results as a dictionary\n\n        Returns:\n            dict : dictionary\n        \"\"\"\n        return self.dict\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.EQ","title":"<code>EQ = pp.Suppress('=')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.ParseResults","title":"<code>ParseResults = Multisim.expr.parse_string(string)</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_0","title":"<code>_expr_0 = variable + EQ + value</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_1","title":"<code>_expr_1 = variable + EQ + array</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_2","title":"<code>_expr_2 = variable + EQ + pp.Group(LBRACE + pp.ZeroOrMore(expr) + RBRACE)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_3","title":"<code>_expr_3 = variable + EQ + pp.Group(LBRACKET + pp.ZeroOrMore(pp.Group(LBRACE + expr + RBRACE)) + RBRACKET)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._expr_4","title":"<code>_expr_4 = pp.Group(variable + pp.Group(LBRACE + pp.ZeroOrMore(expr) + RBRACE))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._number","title":"<code>_number = ppc.number()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._string1","title":"<code>_string1 = pp.Word(pp.alphanums + '._/?-@*')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim._string2","title":"<code>_string2 = pp.quoted_string()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.array","title":"<code>array = pp.Forward()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.dict","title":"<code>dict = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.dot","title":"<code>dot = DotMap()</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.expr","title":"<code>expr = pp.Forward()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.indent","title":"<code>indent = 4</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.output","title":"<code>output = sys.stdout</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.template_path","title":"<code>template_path = None</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.value","title":"<code>value = _string1 | _string2 | _number</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.variable","title":"<code>variable = pp.Word(pp.alphanums + '._/?-@') + pp.Opt('.' + pp.Word(pp.alphanums)).set_parse_action(''.join)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Multisim.__init__","title":"<code>__init__(**kwargs)</code>","text":"Source code in <code>desmondtools/multisim.py</code> <pre><code>def __init__(self, **kwargs):\n    self.template_path = None\n    self.ParseResults = None\n    self.dict = {}\n    self.dot = DotMap()\n    self.output = sys.stdout # do not attempt to close\n    self.indent = 4\n\n    if 'template' in kwargs:\n        template = kwargs['template']\n        template_path = pathlib.Path(template)\n        if template_path.is_file():\n            self.template_path = template_path\n        else:\n            template_path = importlib.resources.files('desmondtools')\n            self.template_path = template_path / template\n        if self.template_path is None:\n            raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), template)\n\n        self.ParseResults = Multisim.expr.parse_file(self.template_path)\n        self.decode()\n\n    elif 'string' in kwargs:\n        string = kwargs['string']\n        try:\n            self.ParseResults = Multisim.expr.parse_string(string)\n            self.decode()\n        except:\n            raise RuntimeError(\"Multisim: cannot parse the input string.\")\n    else:\n        raise RuntimeError(\"Multisim: template filename or string is required.\")\n</code></pre>"},{"location":"index.html#desmondtools.Multisim._write_dict","title":"<code>_write_dict(d, block=False, depth=0)</code>","text":"<p>subroutine of .write() method</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def _write_dict(self, d, block=False, depth=0):\n    \"\"\"subroutine of .write() method\"\"\"\n    spc = ' ' * self.indent * depth\n    if isinstance(d, dict) or isinstance(d, DotMap):\n        for k, v in d.items():\n            k = str(k)\n            if v:\n                if isinstance(v, dict) or isinstance(v, DotMap):\n                    if depth == 0 and block:\n                        self.output.write(spc + k + \" {\\n\")\n                    else:\n                        self.output.write(spc + k + \" = {\\n\")\n                    self._write_dict(v, depth=depth+1)\n                    self.output.write(spc + \"}\\n\")\n                elif isinstance(v, list):\n                    self.output.write(spc + k + \" = [\")\n                    for vv in v:\n                        if isinstance(vv, dict) or isinstance(vv, DotMap): \n                            self.output.write(\"{\\n\")\n                        elif isinstance(vv, list):\n                            self.output.write(\"[\")\n                        self._write_dict(vv, depth=depth+1)\n                        if isinstance(vv, dict) or isinstance(vv, DotMap):\n                            self.output.write(spc + \"}\")\n                        elif isinstance(vv, list):\n                            self.output.write(\"]\")                \n                    self.output.write(\"]\\n\")\n                else:\n                    self.output.write(spc + k + \" = \" + str(v) +\"\\n\")\n            else:\n                if isinstance(v, list) and (not bool(v)):\n                    self.output.write(spc + k + \" = []\\n\")\n                elif (isinstance(v, dict) or isinstance(v, DotMap))and (not bool(v)):\n                    self.output.write(spc + k + \" = {\\n}\\n\")\n                else:\n                    self.output.write(spc + k + \" =   \\n\")\n    elif isinstance(d, list):\n        for v in d:\n            self._write_dict(v, depth=depth+1)\n    else:\n        self.output.write(\" \" + str(d) + \" \")\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.decode","title":"<code>decode()</code>","text":"<p>decode the parsed results into a dictionary and its dotmap</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def decode(self) -&gt; None:\n    \"\"\"decode the parsed results into a dictionary and its dotmap\"\"\"\n    # create .dict\n    if isinstance(self.ParseResults.as_list()[0][0], str): # key\n        self.dict = self.ParseResults.as_dict()\n        Multisim.traverse_dict(self.dict)\n        # handle the case where key has '.'\n        Multisim.unfold_dict_key(self.dict)\n\n    elif isinstance(self.ParseResults.as_list()[0][0], list):\n        self.dict = [] # now self.dict is a list of dictionary\n        for section in self.ParseResults:\n            dict_ = dict(section.as_list())\n            Multisim.traverse_dict(dict_)\n            # handle the case where key has '.'\n            Multisim.unfold_dict_key(dict_)\n            self.dict.append(dict_)\n\n    # create .dot\n    if isinstance(self.dict, list):\n        self.dot = {}\n        for d in self.dict:\n            for k,v in d.items():\n                if k in self.dot:\n                    if isinstance(self.dot[k], list):\n                        self.dot[k].append(v)\n                    else:\n                        self.dot[k] = [self.dot[k], v]\n                else:\n                    self.dot[k] = v\n        self.dot = DotMap(self.dot)\n    else:\n        self.dot = DotMap(self.dict)\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns parsed results as a dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>dictionary</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Returns parsed results as a dictionary\n\n    Returns:\n        dict : dictionary\n    \"\"\"\n    return self.dict\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_dot","title":"<code>to_dot()</code>","text":"<p>Returns parsed results as a DotMap object</p> <p>Returns:</p> Name Type Description <code>DotMap</code> <code>DotMap</code> <p>DotMap object</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def to_dot(self) -&gt; DotMap:\n    \"\"\"Returns parsed results as a DotMap object\n\n    Returns:\n        DotMap : DotMap object\n    \"\"\"\n    return self.dot\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.to_list","title":"<code>to_list()</code>","text":"<p>Returns parsed results as a list</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>list</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def to_list(self) -&gt; list:\n    \"\"\"Returns parsed results as a list\n\n    Returns:\n        list : list\n    \"\"\"\n    return self.ParseResults.as_list()\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.traverse_dict","title":"<code>traverse_dict(d)</code>  <code>staticmethod</code>","text":"<p>Recursively traverse a nested dictionary/list</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>dictionary (to be modified)</p> required Source code in <code>desmondtools/multisim.py</code> <pre><code>@staticmethod\ndef traverse_dict(d) -&gt; None:\n    \"\"\"Recursively traverse a nested dictionary/list\n\n    Args:\n        d (dict): dictionary (to be modified)\n    \"\"\"\n    if isinstance(d, dict):\n        for k,v in d.items():\n            if isinstance(v, dict):\n                Multisim.traverse_dict(v)            \n            elif isinstance(v, list):\n                if v == ['{','}']:\n                    d[k] = {}\n                elif v == ['[',']']:\n                    d[k] = []\n                elif v[0] == '[' and v[-1] == ']':\n                    d[k] = v[1:-1]\n                    Multisim.traverse_dict(d[k])\n                elif v[0] == '{' and v[-1] == '}':\n                    d[k] = dict(v[1:-1])\n                    Multisim.traverse_dict(d[k])\n    elif isinstance(d, list):\n        for k,v in enumerate(d):\n            if isinstance(v, dict):\n                Multisim.traverse_dict(v)\n            elif isinstance(v, list):\n                if v == ['{','}']:\n                    d[k] = {}\n                elif v == ['[',']']:\n                    d[k] = []\n                elif v[0] == '[' and v[-1] == ']':\n                    d[k] = v[1:-1]\n                    Multisim.traverse_dict(d[k])\n                elif v[0] == '{' and v[-1] == '}':\n                    d[k] = dict(v[1:-1])\n                    Multisim.traverse_dict(d[k])\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.unfold_dict_key","title":"<code>unfold_dict_key(d)</code>  <code>staticmethod</code>","text":"<p>Unfold '.' in the keys of a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>dictionary (to be modified)</p> required Source code in <code>desmondtools/multisim.py</code> <pre><code>@staticmethod\ndef unfold_dict_key(d) -&gt; None:\n    \"\"\"Unfold '.' in the keys of a dictionary\n\n    Args:\n        d (dict): dictionary (to be modified)\n    \"\"\"\n    ks = [ k for k in d ]\n    for k in ks:\n        v = d[k]\n        if '.' in k:\n            # d[k] = v --&gt; d[kk[0]] = { kk[1] : v }\n            _u = None\n            _k = k.split('.')[0]\n            for kk in k.split('.')[-1:0:-1]:\n                if _u is None:\n                    _u = {kk : v }\n                else:\n                    _u = {kk : _u}\n            d[_k] = _u\n            del d[k]\n        else:\n            pass\n        if isinstance(v, dict):\n            Multisim.unfold_dict_key(v)\n</code></pre>"},{"location":"index.html#desmondtools.Multisim.write","title":"<code>write(output=None)</code>","text":"<p>Writes DOT object</p> Source code in <code>desmondtools/multisim.py</code> <pre><code>def write(self, output=None):\n    \"\"\"Writes DOT object\"\"\"\n    if isinstance(output, io.IOBase):\n        self.output = output\n    elif isinstance(output, str):\n        self.output = open(output, \"w\")\n\n    if isinstance(self.dict, list):\n        blocks = []\n        for k, v in self.dot.items():\n            if isinstance(v, list):\n                for vv in v:\n                    blocks.append({k:vv})\n            else:\n                blocks.append({k:v})\n        for block in blocks:\n            self._write_dict(block, block=True)\n            self.output.write(\"\\n\")\n    else:\n        self._write_dict(self.dot)\n</code></pre>"},{"location":"index.html#desmondtools.Event","title":"<code>desmondtools.Event</code>","text":"Source code in <code>desmondtools/event.py</code> <pre><code>class Event:\n    def __init__(self, filename:Path | str):\n        if isinstance(filename, Path):\n            result = Multisim.expr.parse_file(filename.as_posix())\n        else:\n            result = Multisim.expr.parse_file(filename)\n        d = result.as_dict()\n        Multisim.traverse_dict(d)\n        self.dot = DotMap(d)\n</code></pre>"},{"location":"index.html#desmondtools.Event.dot","title":"<code>dot = DotMap(d)</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Event.__init__","title":"<code>__init__(filename)</code>","text":"Source code in <code>desmondtools/event.py</code> <pre><code>def __init__(self, filename:Path | str):\n    if isinstance(filename, Path):\n        result = Multisim.expr.parse_file(filename.as_posix())\n    else:\n        result = Multisim.expr.parse_file(filename)\n    d = result.as_dict()\n    Multisim.traverse_dict(d)\n    self.dot = DotMap(d)\n</code></pre>"},{"location":"index.html#desmondtools.Interaction","title":"<code>desmondtools.Interaction</code>","text":"<p>               Bases: <code>Event</code></p> Source code in <code>desmondtools/event.py</code> <pre><code>class Interaction(Event):\n    def __init__(self, filename:Path | str, verbose:bool=False):\n        super().__init__(filename)\n\n        self.num_frames = 0\n        self.HBond = {}\n        self.Hydrophobic = {}\n        self.WaterBridge = {}\n        self.Polar = {}\n        self.HalogenBond = {}\n        self.LigWat = {}\n        self.Metal = {}\n        self.PiCat = {}\n        self.PiPi = {}\n\n        for section in self.dot.Keywords:\n            try:\n                assert section.ProtLigInter.HBondResult\n                self.num_frames = len(section.ProtLigInter.HBondResult)\n                for frame in section.ProtLigInter.HBondResult:\n                    # [[3 \"_:ARG_143:HH22\" d-s \"L-FRAG_0:N6\" ]]\n                    for (frameno, prot, hbond_type, lig) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid, atom) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.HBond:\n                            self.HBond[resSeq]['count'] += 1\n                        else:\n                            self.HBond[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.HBond):\n                    fraction = float(self.HBond[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"HBond {self.HBond[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n\n            try:\n                assert section.ProtLigInter.HydrophobicResult\n                self.num_frames = len(section.ProtLigInter.HydrophobicResult)\n                for frame in section.ProtLigInter.HydrophobicResult:\n                    # [[0 \"_:PHE_223\" L-FRAG_0 ] [0 \"_:ALA_241\" L-FRAG_0 ]]\n                    for (frameno, prot, lig) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.Hydrophobic:\n                            self.Hydrophobic[resSeq]['count'] += 1\n                        else:\n                            self.Hydrophobic[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.Hydrophobic):\n                    fraction = float(self.Hydrophobic[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"Hydrophobic {self.Hydrophobic[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n\n            try:\n                assert section.ProtLigInter.PolarResult\n                self.num_frames = len(section.ProtLigInter.PolarResult)\n                for frame in section.ProtLigInter.PolarResult:\n                    # [[1 \"_:GLU_216:OE2\" b \"L-FRAG_1:N3\" 4.45 ]]\n                    for (frameno, prot, _, lig, _) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid, atom) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.Polar:\n                            self.Polar[resSeq]['count'] += 1\n                        else:\n                            self.Polar[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.Polar):\n                    fraction = float(self.Polar[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"Polar {self.Polar[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n\n            try:\n                assert section.ProtLigInter.WaterBridgeResult\n                self.num_frames = len(section.ProtLigInter.WaterBridgeResult)\n                for frame in section.ProtLigInter.WaterBridgeResult:\n                    # [[3 \"_:GLU_216:OE2\" a \"L-FRAG_0:N2\" a 2431 ]]\n                    for (frameno, prot, _, lig, _, _) in frame:\n                        prot = prot.strip('\\\"')\n                        (_, resid, atom) = prot.split(\":\")\n                        (resName, resSeq) = resid.split(\"_\")\n                        resSeq = int(resSeq)\n                        if resSeq in self.WaterBridge:\n                            self.WaterBridge[resSeq]['count'] += 1\n                        else:\n                            self.WaterBridge[resSeq] = {'resName': resName, 'count':1 }\n                for resSeq in sorted(self.WaterBridge):\n                    fraction = float(self.WaterBridge[resSeq]['count'])/self.num_frames\n                    if verbose:\n                        print(f\"WaterBridge {self.WaterBridge[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n            except:\n                pass\n</code></pre>"},{"location":"index.html#desmondtools.Interaction.HBond","title":"<code>HBond = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.HalogenBond","title":"<code>HalogenBond = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.Hydrophobic","title":"<code>Hydrophobic = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.LigWat","title":"<code>LigWat = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.Metal","title":"<code>Metal = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.PiCat","title":"<code>PiCat = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.PiPi","title":"<code>PiPi = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.Polar","title":"<code>Polar = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.WaterBridge","title":"<code>WaterBridge = {}</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.num_frames","title":"<code>num_frames = len(section.ProtLigInter.WaterBridgeResult)</code>  <code>instance-attribute</code>","text":""},{"location":"index.html#desmondtools.Interaction.__init__","title":"<code>__init__(filename, verbose=False)</code>","text":"Source code in <code>desmondtools/event.py</code> <pre><code>def __init__(self, filename:Path | str, verbose:bool=False):\n    super().__init__(filename)\n\n    self.num_frames = 0\n    self.HBond = {}\n    self.Hydrophobic = {}\n    self.WaterBridge = {}\n    self.Polar = {}\n    self.HalogenBond = {}\n    self.LigWat = {}\n    self.Metal = {}\n    self.PiCat = {}\n    self.PiPi = {}\n\n    for section in self.dot.Keywords:\n        try:\n            assert section.ProtLigInter.HBondResult\n            self.num_frames = len(section.ProtLigInter.HBondResult)\n            for frame in section.ProtLigInter.HBondResult:\n                # [[3 \"_:ARG_143:HH22\" d-s \"L-FRAG_0:N6\" ]]\n                for (frameno, prot, hbond_type, lig) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.HBond:\n                        self.HBond[resSeq]['count'] += 1\n                    else:\n                        self.HBond[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.HBond):\n                fraction = float(self.HBond[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"HBond {self.HBond[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.HydrophobicResult\n            self.num_frames = len(section.ProtLigInter.HydrophobicResult)\n            for frame in section.ProtLigInter.HydrophobicResult:\n                # [[0 \"_:PHE_223\" L-FRAG_0 ] [0 \"_:ALA_241\" L-FRAG_0 ]]\n                for (frameno, prot, lig) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.Hydrophobic:\n                        self.Hydrophobic[resSeq]['count'] += 1\n                    else:\n                        self.Hydrophobic[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.Hydrophobic):\n                fraction = float(self.Hydrophobic[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"Hydrophobic {self.Hydrophobic[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.PolarResult\n            self.num_frames = len(section.ProtLigInter.PolarResult)\n            for frame in section.ProtLigInter.PolarResult:\n                # [[1 \"_:GLU_216:OE2\" b \"L-FRAG_1:N3\" 4.45 ]]\n                for (frameno, prot, _, lig, _) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.Polar:\n                        self.Polar[resSeq]['count'] += 1\n                    else:\n                        self.Polar[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.Polar):\n                fraction = float(self.Polar[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"Polar {self.Polar[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n\n        try:\n            assert section.ProtLigInter.WaterBridgeResult\n            self.num_frames = len(section.ProtLigInter.WaterBridgeResult)\n            for frame in section.ProtLigInter.WaterBridgeResult:\n                # [[3 \"_:GLU_216:OE2\" a \"L-FRAG_0:N2\" a 2431 ]]\n                for (frameno, prot, _, lig, _, _) in frame:\n                    prot = prot.strip('\\\"')\n                    (_, resid, atom) = prot.split(\":\")\n                    (resName, resSeq) = resid.split(\"_\")\n                    resSeq = int(resSeq)\n                    if resSeq in self.WaterBridge:\n                        self.WaterBridge[resSeq]['count'] += 1\n                    else:\n                        self.WaterBridge[resSeq] = {'resName': resName, 'count':1 }\n            for resSeq in sorted(self.WaterBridge):\n                fraction = float(self.WaterBridge[resSeq]['count'])/self.num_frames\n                if verbose:\n                    print(f\"WaterBridge {self.WaterBridge[resSeq]['resName']}_{resSeq} {fraction:5.3f} {self.num_frames}\")\n        except:\n            pass\n</code></pre>"},{"location":"index.html#desmondtools.cli","title":"<code>desmondtools.cli</code>","text":""},{"location":"index.html#desmondtools.cli.SCHRODINGER","title":"<code>SCHRODINGER = os.environ['SCHRODINGER']</code>  <code>module-attribute</code>","text":""},{"location":"index.html#desmondtools.cli.USER","title":"<code>USER = os.environ['USER']</code>  <code>module-attribute</code>","text":""},{"location":"index.html#desmondtools.cli.multisim","title":"<code>multisim = '{}/utilities/multisim'.format(SCHRODINGER)</code>  <code>module-attribute</code>","text":""},{"location":"index.html#desmondtools.cli.schrodinger_hosts","title":"<code>schrodinger_hosts = '{}/schrodinger.hosts'.format(SCHRODINGER)</code>  <code>module-attribute</code>","text":""},{"location":"index.html#desmondtools.cli.schrodinger_run","title":"<code>schrodinger_run = '{}/run'.format(SCHRODINGER)</code>  <code>module-attribute</code>","text":""},{"location":"index.html#desmondtools.cli.script_path","title":"<code>script_path = files('desmondtools.script')</code>  <code>module-attribute</code>","text":""},{"location":"index.html#desmondtools.cli.batch_cmsinfo","title":"<code>batch_cmsinfo()</code>","text":"Source code in <code>desmondtools/cli/schrodinger_run.py</code> <pre><code>def batch_cmsinfo() -&gt; None:\n    argv = sys.argv[1:]\n    subprocess.run([schrodinger_run, \n                    script_path.joinpath('batch-desmond-cmsinfo.py')] + argv)\n</code></pre>"},{"location":"index.html#desmondtools.cli.batch_dihedral","title":"<code>batch_dihedral()</code>","text":"Source code in <code>desmondtools/cli/schrodinger_run.py</code> <pre><code>def batch_dihedral() -&gt; None:\n    argv = sys.argv[1:]\n    subprocess.run([schrodinger_run, \n                    script_path.joinpath('batch-desmond-dihedral.py')] + argv)\n</code></pre>"},{"location":"index.html#desmondtools.cli.batch_distance","title":"<code>batch_distance()</code>","text":"Source code in <code>desmondtools/cli/schrodinger_run.py</code> <pre><code>def batch_distance() -&gt; None:\n    argv = sys.argv[1:]\n    subprocess.run([schrodinger_run, \n                    script_path.joinpath('batch-desmond-distance.py')] + argv)\n</code></pre>"},{"location":"index.html#desmondtools.cli.batch_ligrmsd","title":"<code>batch_ligrmsd()</code>","text":"Source code in <code>desmondtools/cli/schrodinger_run.py</code> <pre><code>def batch_ligrmsd() -&gt; None:\n    argv = sys.argv[1:]\n    subprocess.run([schrodinger_run, \n                    script_path.joinpath('batch-desmond-ligrmsd.py')] + argv)\n</code></pre>"},{"location":"index.html#desmondtools.cli.batch_maeinfo","title":"<code>batch_maeinfo()</code>","text":"Source code in <code>desmondtools/cli/schrodinger_run.py</code> <pre><code>def batch_maeinfo() -&gt; None:\n    argv = sys.argv[1:]\n    subprocess.run([schrodinger_run, \n                    script_path.joinpath('batch-desmond-maeinfo.py')] + argv)\n</code></pre>"},{"location":"index.html#desmondtools.cli.batch_report","title":"<code>batch_report()</code>","text":"Source code in <code>desmondtools/cli/schrodinger_run.py</code> <pre><code>def batch_report() -&gt; None:\n    argv = sys.argv[1:]\n    subprocess.run([schrodinger_run, \n                    script_path.joinpath('batch-desmond-report.py')] + argv)\n</code></pre>"},{"location":"index.html#desmondtools.cli.batch_rg","title":"<code>batch_rg()</code>","text":"Source code in <code>desmondtools/cli/schrodinger_run.py</code> <pre><code>def batch_rg() -&gt; None:\n    argv = sys.argv[1:]\n    subprocess.run([schrodinger_run, \n                    script_path.joinpath('batch-desmond-rg.py')] + argv)\n</code></pre>"},{"location":"index.html#desmondtools.cli.batch_rmsx","title":"<code>batch_rmsx()</code>","text":"Source code in <code>desmondtools/cli/schrodinger_run.py</code> <pre><code>def batch_rmsx() -&gt; None:\n    argv = sys.argv[1:]\n    subprocess.run([schrodinger_run, \n                    script_path.joinpath('batch-desmond-rmsx.py')] + argv)\n</code></pre>"}]}